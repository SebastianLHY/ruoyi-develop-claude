# 📋 详细执行步骤

> **版本**: v2.18.0  
> **所属**: dev.md v2.18.0  
> **用途**: 13个步骤的详细执行指南（含智能体集成+依赖检查+自动回滚+检查点续传+可视化增强）  
> **最后更新**: 2026-01-29  
> **智能体**: 11个智能体全自动协作  
> **v2.18.0核心功能**: 
> - ✅ 智能推荐系统 - 准确率>95%，标准CRUD自动使用生成器
> - ✅ 自动回滚机制 - L1/L2级别失败自动回滚修复
> - ✅ 回归测试套件 - 85%覆盖率，4类测试全自动
> - ✅ 可视化Dashboard - Token消耗图表、实时进度监控、模式对比

---

## 📊 可视化增强 Dashboard

### 🎯 实时进度仪表盘

```
┌─────────────────────────────────────────────────────────────────────┐
│                   🚀 开发进度实时监控 Dashboard                       │
└─────────────────────────────────────────────────────────────────────┘

📈 整体进度: ████████████████░░░░ 80% (步骤9/11)

┌─────────────┬────────┬──────────┬─────────┬──────────────┐
│ 步骤        │ 状态   │ Token    │ 耗时    │ 质量评分     │
├─────────────┼────────┼──────────┼─────────┼──────────────┤
│ 1.需求澄清  │ ✅     │ 450      │ 8分钟   │ ⭐⭐⭐⭐⭐    │
│ 2.技术设计  │ ✅     │ 680      │ 12分钟  │ ⭐⭐⭐⭐⭐    │
│ 3.Git初始化 │ ✅     │ 50       │ 2分钟   │ ⭐⭐⭐⭐⭐    │
│ 4.文档初始化│ ✅     │ 320      │ 5分钟   │ ⭐⭐⭐⭐     │
│ 5.数据库设计│ ✅     │ 890      │ 15分钟  │ ⭐⭐⭐⭐⭐    │
│ 5.5.生成决策│ ✅     │ 150      │ 3分钟   │ ⭐⭐⭐⭐⭐    │
│ 6.后端开发  │ ✅     │ 1,200    │ 25分钟  │ ⭐⭐⭐⭐     │
│ 7.前端开发  │ ✅     │ 1,800    │ 35分钟  │ ⭐⭐⭐⭐     │
│ 8.测试验证  │ ✅     │ 980      │ 18分钟  │ ⭐⭐⭐⭐⭐    │
│ 9.质量检查  │ ⏳     │ 420      │ 10分钟  │ 进行中...    │
│ 9.5.性能分析│ 🔜     │ -        │ -       │ 待执行       │
│ 10.文档更新 │ 🔜     │ -        │ -       │ 待执行       │
│ 11.Git提交  │ 🔜     │ -        │ -       │ 待执行       │
└─────────────┴────────┴──────────┴─────────┴──────────────┘

💰 Token累计: 6,940 / 预算: 8,000 (剩余: 1,060) ✅
⏱️  总耗时: 133分钟 / 预估: 155分钟 (提前: 22分钟) 🎯
📊 质量得分: 95/100 (优秀) ⭐⭐⭐⭐⭐

实时提示:
✅ Token消耗健康，当前处于绿色区间
✅ 进度超前，按时完成有保障
⚠️  步骤9质量检查中，预计10分钟完成
💡 建议: 步骤9.5性能分析将自动执行(静默模式，<200 tokens)
```

---

### 💰 Token消耗可视化对比

```
┌─────────────────────────────────────────────────────────────────────┐
│              Token消耗对比 - 不同生成模式（11步完成）                 │
└─────────────────────────────────────────────────────────────────────┘

方式B (全AI生成)      ████████████████████ 12,500 tokens  基准线
                      ↑ 
方式C4 (后端AI+前端生成器)  ██████████████░░░░░░ 9,800 tokens   ↓21.6%
                      ↑
方式C3 (后端生成器+前端AI)  ████████████░░░░░░░░ 8,600 tokens   ↓31.2%
                      ↑
方式A (全生成器)      ████████░░░░░░░░░░░░ 5,900 tokens   ↓52.8%
                      
                      0     2.5K   5K    7.5K   10K   12.5K  15K

📊 详细对比数据:

┌──────────┬───────────┬──────────┬──────────┬──────────┐
│ 步骤     │ 方式A     │ 方式C3   │ 方式C4   │ 方式B    │
├──────────┼───────────┼──────────┼──────────┼──────────┤
│ 1-5      │ 2,390     │ 2,390    │ 2,390    │ 2,390    │
│ 5.5      │ 150       │ 200      │ 200      │ 150      │
│ 6.后端   │ 900       │ 900      │ 3,000    │ 3,000    │
│ 7.前端   │ 1,500     │ 3,000    │ 1,500    │ 3,000    │
│ 8-9      │ 760       │ 910      │ 910      │ 1,460    │
│ 9.5      │ 120       │ 150      │ 150      │ 150      │
│ 10-11    │ 80        │ 1,050    │ 1,650    │ 2,350    │
├──────────┼───────────┼──────────┼──────────┼──────────┤
│ **合计** │ **5,900** │ **8,600**│ **9,800**│ **12,500**│
│ **节省** │ **52.8%** │ **31.2%**│ **21.6%**│ **0%**   │
└──────────┴───────────┴──────────┴──────────┴──────────┘

💡 Token优化建议:
   • 标准CRUD → 使用方式A，节省52.8% ⭐⭐⭐⭐⭐
   • 定制前端 → 使用方式C3，节省31.2% ⭐⭐⭐⭐⭐
   • 定制后端 → 使用方式C4，节省21.6% ⭐⭐⭐⭐
   • 复杂业务 → 使用方式B（灵活性最高）⭐⭐⭐
```

---

### ⚡ 实时Token消耗趋势图

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Token实时消耗曲线 (累计)                           │
└─────────────────────────────────────────────────────────────────────┘

12.5K ┤                                              ╭─ 方式B (全AI)
      │                                         ╭────╯
10K   ┤                                    ╭────╯
      │                               ╭────╯     ╭─── 方式C4
7.5K  ┤                          ╭────╯     ╭───╯
      │                     ╭────╯      ╭───╯
5K    ┤                ╭────╯      ╭───╯    ╭────── 方式C3
      │           ╭────╯       ╭───╯   ╭────╯
2.5K  ┤      ╭────╯       ╭───╯   ╭───╯  ╭───────── 方式A (生成器)
      │  ╭───╯        ╭───╯   ╭───╯  ╭──╯
0     └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴────────────────────────
      1  2  3  4  5 5.5 6  7  8  9 9.5 10 11  步骤

🎯 关键观察点:
   • 步骤6-7是Token消耗高峰期（后端+前端代码生成）
   • 方式A在步骤6-7节省最明显（↓4,600 tokens）
   • 步骤9.5性能分析已优化至极低消耗（<200 tokens）
   • 步骤1-5和8-11的Token消耗各模式基本一致

📊 实时警报系统:
   ✅ 当前: 6,940 tokens (绿色区间，健康)
   ⚠️ 8,000-15,000 tokens: 黄色警告
   🔴 >15,000 tokens: 红色预警，建议切换生成器模式
```

---

### 🔄 各模式效率对比雷达图

```
┌─────────────────────────────────────────────────────────────────────┐
│                  生成模式 - 多维度对比雷达图                          │
└─────────────────────────────────────────────────────────────────────┘

             Token节省 (5)
                  ⭐
                 /|\
                / | \
               /  |  \
              /   |   \
    代码质量 ⭐---+---⭐ 开发速度
           /     |     \
          /      |      \
         /       |       \
        /        |        \
       ⭐--------+--------⭐
    灵活性              学习成本


方式A (全生成器):        方式C3 (后端生成器+前端AI):
  Token节省: ████████ 5    Token节省: ██████░░ 4
  开发速度:  █████████ 5    开发速度:  ███████░ 4
  代码质量:  ████████░ 4    代码质量:  █████████ 5
  灵活性:    ████░░░░░ 2    灵活性:    ███████░░ 4
  学习成本:  ███████░░ 4    学习成本:  ████████░ 4

方式C4 (后端AI+前端生成器): 方式B (全AI生成):
  Token节省: ████░░░░░ 2    Token节省: ░░░░░░░░░ 0
  开发速度:  ███████░░ 4    开发速度:  ██████░░░ 3
  代码质量:  █████████ 5    代码质量:  █████████ 5
  灵活性:    ███████░░ 4    灵活性:    █████████ 5
  学习成本:  ████████░ 4    学习成本:  █████████ 5


📋 评分标准 (1-5):
   5 = 优秀 ⭐⭐⭐⭐⭐
   4 = 良好 ⭐⭐⭐⭐
   3 = 一般 ⭐⭐⭐
   2 = 偏低 ⭐⭐
   1 = 较差 ⭐

💡 智能推荐:
   ✅ 标准CRUD → 方式A (Token节省+速度双优)
   ✅ 定制UI → 方式C3 (质量+灵活性平衡)
   ✅ 复杂逻辑 → 方式B (灵活性最高)
   ✅ 混合需求 → 方式C4 (后端灵活+前端高效)
```

---

### 📈 项目质量趋势监控

```
┌─────────────────────────────────────────────────────────────────────┐
│                    质量指标实时监控面板                               │
└─────────────────────────────────────────────────────────────────────┘

🎯 代码质量得分: 95/100 ⭐⭐⭐⭐⭐

┌─────────────────────────────────────────────────────────────┐
│ 测试覆盖率        ████████████████░░░░ 82%  ✅ (目标: >80%) │
│ 代码规范性        ██████████████████░░ 92%  ✅ (目标: >85%) │
│ 安全扫描          ████████████████████ 100% ✅ (无漏洞)     │
│ 性能评分          ████████████████░░░░ 88%  ✅ (良好)       │
│ 文档完整性        ██████████████████░░ 90%  ✅ (完善)       │
└─────────────────────────────────────────────────────────────┘

📊 历史趋势 (最近5次提交):

100% ┤                                    ●
     │                              ●           质量稳步提升 📈
 90% ┤                        ●
     │                  ●
 80% ┤            ●
     │
 70% └────┴────┴────┴────┴────┴────
      v1.0 v1.1 v1.2 v1.3 v1.4 当前

⚠️  质量警报:
   ✅ 所有指标达标
   💡 建议: 测试覆盖率可继续提升至85%+

🔔 自动触发:
   • 测试覆盖率<80% → 自动提示补充测试
   • 代码规范性<85% → 自动触发@code-reviewer
   • 安全扫描发现漏洞 → 自动触发@bug-detective
```

---

### ⏱️ 性能分析执行概览

```
┌─────────────────────────────────────────────────────────────────────┐
│            步骤9.5 性能分析 - 静默自动执行模式                        │
└─────────────────────────────────────────────────────────────────────┘

执行模式: 🤖 静默自动执行 (所有场景)
状态: ⏳ 执行中... (进度: 60%)

┌─────────────────────────────────────────────────────────────┐
│ SQL性能检查       ████████████████████ 100% ✅ 已完成       │
│ N+1查询检测       ████████████████████ 100% ✅ 已完成       │
│ 索引优化建议      ████████████████████ 100% ✅ 已完成       │
│ 内存泄漏检测      ████████████████████ 100% ✅ 已完成 🆕    │
│ 并发瓶颈检测      ████████████████████ 100% ✅ 已完成 🆕    │
│ 大对象处理        ████████████████████ 100% ✅ 已完成       │
│ 缓存优化          ████████████████████ 100% ✅ 已完成       │
└─────────────────────────────────────────────────────────────┘

⏱️  执行完成: 2分钟
💰 Token消耗: 180 / 200 (极低) ✅
📄 输出方式: 直接输出优化建议清单 (不生成报告文件)

🎯 已发现问题 (7项):
   ⚠️  用户表查询缺失索引 (user_phone)
   ⚠️  订单列表存在N+1查询风险
   ⚠️  静态集合CacheManager.CACHE无限增长 (内存泄漏) 🆕
   ⚠️  ThreadLocal未清理 (UserContext.USER_HOLDER) 🆕
   ⚠️  synchronized范围过大 (SportRecordService.getAllRecords) 🆕
   ⚠️  线程池配置不当 (corePoolSize=1太小) 🆕
   💡 建议添加查询缓存 (用户信息、角色权限)

实时统计:
   ✅ 执行率: 100% (所有场景自动执行)
   ✅ 响应时间: <2分钟 (极快)
   ✅ 打断率: 0% (静默执行，不影响开发流程)
```

---

## 步骤 1：需求澄清与分析

### 🔍 前置依赖检查

**必需检查项**: 无（首个步骤）

**推荐检查项**: 无

**说明**: 步骤1是开发流程的起点，无前置依赖要求。

---

### 执行内容
- **执行方式**：通过结构化提问理解业务需求，避免假设和误解
- **核心功能**：
	- 智能需求提取与澄清
	- 结构化提问策略（优先使用选择题）
	- 需求冲突检测
	- 自动生成需求文档
- **必须确认的内容**：
	1. **功能概述**
		- 这个功能的核心目标是什么？解决什么业务问题？
		- 预期的用户角色是谁？（管理员/普通用户/游客）
	2. **业务规则**
		- 核心业务逻辑是什么？（如：订单创建需要哪些前置条件）
		- 状态流转规则是什么？（如：草稿→待审核→已通过→已拒绝）
		- 权限控制要求是什么？（哪些角色可以执行哪些操作）
	3. **数据边界**
		- 必填字段有哪些？可选字段有哪些？
		- 字段长度/取值范围限制是什么？
		- 默认值是什么？
		- 是否需要唯一性约束？
	4. **关联关系**
		- 是否关联其他业务模块？（如：订单关联用户、商品）
		- 是否需要查询关联数据？
		- 是否需要级联操作？（如：删除订单时删除订单项）
	5. **特殊需求**
		- 是否需要导入导出功能？
		- 是否需要数据权限控制？（如：只能看自己部门的数据）
		- 是否需要操作日志记录？
		- 是否需要审批流程？
- **提问方式**：
	- 优先使用选择题（是/否、A/B/C选项）
	- 一次只问一个问题，避免信息过载
	- 对不明确的回答进行追问
- **输出产物**：
	- 功能需求清单（What）
	- 业务规则描述（How）
	- 数据字典初稿（Which）
	- 验收标准列表（Done）
- **备注**：智能体会自动完成需求澄清工作流，无需手动干预
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：需求不明确时自动重新提问，最多3次
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤1](./dev-rollback-guide.md#步骤1失败需求澄清)
- **💾 检查点** 🆕：
	- ✅ **自动保存**：步骤完成后自动创建检查点 `cp_step1_completed`
	- ✅ **保存内容**：需求文档、业务规则、数据字典、验收标准
	- ✅ **恢复能力**：失败时可恢复到此检查点，避免重新澄清需求

---

## 步骤 2：技术设计与模块规划

### 🔍 前置依赖检查

**必需检查项**: 无

**推荐检查项**:
- ⚠️ 需求文档存在（建议先完成步骤1需求澄清）
- ⚠️ 业务规则明确（建议先明确业务规则）

**检查失败处理**:
- 推荐项警告会询问是否继续
- 建议完成步骤1后再执行步骤2，以确保技术设计基于明确的需求

**详细检查清单**: [dev-dependency-check.md - 步骤2](./dev-dependency-check.md#步骤2技术设计)

---

### 执行内容
- **执行方式**：规划技术实现方案并确定模块归属
- **⚠️ 重要说明**：此步骤为**设计阶段**，仅规划方案，不生成可执行代码。实际SQL脚本在步骤5生成。
- **设计产出**：
	1. **数据库设计方案**
		- 规划涉及的数据库表结构（表名、字段类型、长度、索引、关联关系）
		- 定义表名前缀biz_
		- 确定主键策略（雪花ID/自增ID）
		- 规划索引策略（普通索引/唯一索引/联合索引）
		- 📝 **注意**：此步骤仅输出设计方案（文档形式），实际DDL SQL脚本在步骤5生成
	2. **API接口设计方案**
		- 设计 RESTful 接口路径（如：`/system/user`、`/sport/record`）
		- 定义请求/响应模型（Bo、Vo、Dto）
		- 规划接口权限标识（如：`system:user:list`）
	3. **前端页面设计方案**
		- 规划页面布局（五区布局、组件划分）
		- 确定路由路径和权限标识
		- 规划页面交互流程
	4. **数据流转模式**
		- 定义 Bo → Entity → Vo 转换规则
		- 规划缓存策略（如需要）
	5. **📦 模块归属确认**（必须在此步骤完成）
		- **执行流程**：
			1. 读取项目模块结构：`ls -R ruoyi-modules`
			2. 识别现有模块：`ruoyi-system`、`ruoyi-demo`、`ruoyi-generator` 等
			3. 检查已存在的业务模块
			4. 询问用户模块归属：
				```
				检测到以下现有模块：
				1. ruoyi-system (系统管理模块)
				2. ruoyi-demo (示例演示模块)
				3. [新建模块] ruoyi-business-[业务名] (如 ruoyi-business-order)
				
				请选择代码生成位置 [1/2/3]:
				```
			5. **情况 A：选择现有模块**
				- 记录模块路径：`ruoyi-modules/ruoyi-business-[业务名]`
				- 记录包路径：`org.dromara.[业务名]`
			6. **情况 B：新建模块**
				- **多模块处理规则**：
					- 如需创建多个模块，按顺序逐个创建
					- 完成一个模块后再处理下一个
					- 避免并行创建导致配置遗漏
				
				- **模块命名确认**：
					```
					建议模块命名格式：ruoyi-business-[业务名]
					示例：
					- ruoyi-business-order (订单模块)
					- ruoyi-business-inventory (库存模块)
					- ruoyi-business-health (健康模块)
					
					请输入模块名称：
					```
				- 确认最终模块名
				- 规划标准Maven模块目录结构
				- 记录到设计文档中，在步骤6时创建
- **⚠️ 重要**: 模块归属确定后，会影响步骤4文档组织、步骤5表名前缀、步骤6代码路径
- **激活技能：`architecture-design`**
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：仅设计阶段失败时自动重新设计，最多2次
	- ⚠️ **需用户确认**（L3级别）：已执行步骤5+时需用户确认回滚方案
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤2](./dev-rollback-guide.md#步骤2失败技术设计)
- **💾 检查点** 🆕：
	- ✅ **自动保存**：步骤完成后自动创建检查点 `cp_step2_completed`
	- ✅ **保存内容**：技术设计文档、数据库设计方案、API接口设计、模块归属信息
	- ✅ **恢复能力**：后续步骤失败时可回滚到此检查点重新实现

---

## 步骤 3：Git分支管理

### 🔍 前置依赖检查

**必需检查项**: 无

**推荐检查项**:
- ⚠️ 技术设计文档存在（建议先完成步骤2技术设计）
- ⚠️ 模块归属已确定（建议先确定模块路径）

**检查失败处理**:
- 推荐项警告会询问是否继续
- 建议完成步骤2后再创建Git分支，以便规划合理的分支命名

**详细检查清单**: [dev-dependency-check.md - 步骤3](./dev-dependency-check.md#步骤3git初始化)

---

### 执行内容
- **执行方式**：确保代码在正确的分支上开发，为后续文档和代码提供版本控制基础
- **检查项目是否已有 Git 管理**：
	- 检测 `.git` 目录是否存在
	- **情况 A：项目未初始化 Git**
		- ⚠️ 提醒用户：「当前项目未进行 Git 版本控制管理，建议立即初始化 Git 仓库以确保代码可追溯性。」
		- 询问用户：「是否已初始化 Git 仓库？」
		- 等待用户答复确认
		- 用户确认后，再次检查 `.git` 目录：
			- ✅ **已存在** → 继续执行初始化命令
			- ❌ **仍不存在** → 再次提醒并等待用户手动初始化
		- 执行 Git 初始化流程：
			```bash
			# 1. 确认仓库名和 GitHub 用户名
			echo "# [仓库名]" >> README.md
			git init
			git add README.md
			git commit -m "first commit"
			git branch -M main
			git remote add origin https://github.com/[git用户名]/[仓库名].git
			git push -u origin main
			```
			- 其中 `[仓库名]` 和 `[git用户名]` 需向用户确认
	- **情况 B：项目已有 Git 管理**
		- ✅ 直接激活技能：`git-workflow`
		- 创建功能开发分支（如：`feature/[功能名]`）
		- 后续开发按照 Git 工作流规范进行
- **⚠️ 重要提示**：
	- 确保在功能分支创建后，再执行步骤4的文档初始化
	- 这样可以保证所有文档从一开始就在正确的分支上
- **⚠️ 失败处理**：如Git初始化失败，参见 [回滚决策树 - 步骤3](./dev-rollback-guide.md#步骤3失败git初始化)

---

## 步骤 4：文档初始化与内容填充

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 Git分支已创建（必须先完成步骤3）
- 🚫 需求文档存在（必须先完成步骤1）
- 🚫 技术设计存在（必须先完成步骤2）

**推荐检查项**: 无

**检查失败处理**:
- 必需项检查失败会暂停执行
- 系统会提示需要完成的前置步骤
- 完成后输入'retry'重新检查

**详细检查清单**: [dev-dependency-check.md - 步骤4](./dev-dependency-check.md#步骤4文档初始化)

---

### 执行内容
- **执行方式**：在功能分支上创建项目文档，记录需求和任务规划
- **执行指令**：`commands/init-docs.md`
- **自动填充内容**（基于步骤1-2的分析结果）：
	1. **需求文档**（`docs/需求文档.md`）
		- 自动生成功能需求清单（编号、名称、优先级、状态）
		- 自动生成验收标准（根据业务规则转化为可验证条件）
	2. **项目状态文档**（`docs/项目状态.md`）
		- 初始化项目进度为 0%，状态为"开发中"
		- 记录模块规划（数据库表、API接口、前端页面的清单）
		- 生成待办任务列表（数据库→后端→前端→测试）
	3. **待办清单文档**（`docs/待办清单.md`）
		- 自动生成待办任务（数据库设计、后端开发、前端开发、测试验证）
		- 自动设置任务优先级（高优先级：数据库→后端→前端→测试）
- **⚠️ 注意**：
	- 文档创建后，立即提交到功能分支：
		```bash
		git add docs/
		git commit -m "docs: 初始化项目文档"
		```

---

## 步骤 5：数据库设计（SQL脚本生成）

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 数据库设计方案存在（必须先完成步骤2）
- 🚫 Git分支已创建（必须先完成步骤3）
- 🚫 项目文档已初始化（必须先完成步骤4）

**推荐检查项**:
- ⚠️ sql目录存在（不存在会自动创建）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 系统会提示补救措施
- 完成后输入'retry'重新检查

**详细检查清单**: [dev-dependency-check.md - 步骤5](./dev-dependency-check.md#步骤5数据库设计)

---

### 执行内容
- **执行方式**：基于步骤2的设计方案，编写可执行的数据库脚本
- **⚠️ 重要说明**：此步骤为**实施阶段**，生成可执行的SQL脚本，需要在Git分支上执行。
- **前置依赖**：
	- ✅ 步骤2已完成数据库设计方案（表结构、字段、索引）
	- ✅ 步骤3已创建Git功能分支
	- ✅ 步骤4已初始化项目文档
- **产出内容**：
	1. **建表SQL脚本（DDL）**
		- 生成完整的 `CREATE TABLE` 语句
		- 包含字段定义、数据类型、长度、默认值、注释
		- 包含主键、索引、唯一约束定义
		- 包含6个标准审计字段（create_time、create_by等）
		- 脚本路径：`./claud/sql/business/[表名].sql`
	2. **数据字典SQL（DML）**
		- 插入字典类型数据（`sys_dict_type`）
		- 插入字典数据（`sys_dict_data`）
		- 脚本路径：`./claude/sql/business/dict_data.sql`
	3. **菜单权限SQL（DML）**
		- 插入菜单数据（`sys_menu`）
		- 配置权限标识（如：`system:user:list`）
		- 脚本路径：`./claude/sql/business/menu_data.sql`
- **代码规范**：
	- 表名使用小写下划线命名（snake_case）
	- 存储引擎使用 InnoDB
	- 字符集使用 utf8mb4
	- 所有字段必须添加 COMMENT 注释
	- 避免使用物理外键约束（使用逻辑外键）
- **执行验证**：
	```bash
	# 1. 在数据库中执行SQL脚本
	mysql -u root -p < sql/business/[表名].sql
	
	# 2. 验证表是否创建成功
	SHOW TABLES LIKE '[表名]';
	DESC [表名];
	
	# 3. 验证字典和菜单数据是否插入成功
	SELECT * FROM sys_dict_type WHERE dict_type = '[字典类型]';
	SELECT * FROM sys_menu WHERE menu_name = '[菜单名称]';
	```
- **Git提交**：
	```bash
	# 提交SQL脚本到Git
	git add sql/
	git commit -m "feat: 添加business数据库表结构"
	```
- **➡️ 激活技能：`database-ops`**
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：SQL语法错误自动修正并重新执行，最多3次
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤5](./dev-rollback-guide.md#步骤5失败数据库设计)
- **💾 检查点** 🆕：
	- ✅ **自动保存**：步骤完成后自动创建检查点 `cp_step5_completed`
	- ✅ **保存内容**：SQL脚本、数据库表结构、Git commit信息
	- ✅ **恢复能力**：后端/前端开发失败时可回滚到此检查点

---

## 步骤 5.5：代码生成方式统一决策（Token优化）🆕

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 DDL SQL脚本已生成（必须先完成步骤5）

**推荐检查项**:
- ⚠️ 数据库表已创建（建议先执行SQL脚本）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 推荐项警告会询问是否继续
- 建议先执行SQL脚本创建数据库表

**详细检查清单**: [dev-dependency-check.md - 步骤5.5](./dev-dependency-check.md#步骤55代码生成方式选择)

---

### 执行内容

- **执行方式**：**一次性决策后端和前端的代码生成方式**，减少重复决策
- **核心功能**：
	- 自动检测代码生成器可用性
	- **🤖 智能推荐最优生成方式**（基于需求特征自动分析）🆕
	- 智能推荐最优生成方式（**后端+前端统一决策**）
	- 提供统一配置清单（如选择代码生成器）
	- 验证生成结果并回查
	- 协调前端终端类型检测（PC/Mobile）

---

### 🤖 智能推荐机制（自动分析最优方案）🆕

**执行方式**：在询问用户前，先自动分析需求特征，智能推荐最优生成方式

#### 分析维度

1. **功能复杂度**（基于步骤1需求分析）
   - 简单：标准CRUD（增删改查+分页+条件筛选）
   - 中等：CRUD + 业务逻辑（状态流转、数据校验、权限控制）
   - 复杂：复杂业务流程（多步审批、数据关联、统计分析）

2. **UI定制化程度**（基于步骤1需求分析）
   - 标准：表格+表单+基础组件（符合若依默认风格）
   - 定制：特殊交互、自定义组件、数据可视化
   - 高度定制：全新UI设计、复杂动画、特殊布局

3. **数据表特征**（基于步骤5数据库设计）
   - 简单表：字段<15个，无关联，单表操作
   - 中等表：字段15-30个，1-2个关联，主表+明细
   - 复杂表：字段>30个，多表关联，树形/主子表结构

4. **业务类型**（基于步骤2技术设计）
   - 管理后台：后台管理功能，PC端为主
   - 用户端：面向C端用户，移动端为主
   - 混合端：同时支持PC和移动端

#### 智能推荐规则

```markdown
🤖 正在分析需求特征...

分析结果：
- 功能类型：运动记录管理（CRUD + 统计分析）
- 复杂度：中等（包含数据统计、日期范围查询）
- UI需求：标准表格 + 统计图表（需要数据可视化）
- 数据表：单表，字段18个，无复杂关联
- 终端类型：PC端后台管理

🎯 智能推荐结果：

【推荐方案 - 方式C3】⭐⭐⭐⭐⭐
后端使用代码生成器 + 前端使用AI（部分定制）

推荐理由：
✅ 后端标准CRUD适合生成器（节省70% Token）
✅ 前端需要图表组件，AI生成更灵活
✅ 混合模式兼顾效率和定制化
✅ 预计节省50% Token，同时保证UI质量

备选方案：
- 方式A：后端+前端都用生成器（如图表需求简单可选）
- 方式B：后端+前端都用AI（如需高度定制可选）
```

#### 推荐规则表

| 后端复杂度 | 前端定制化 | 推荐方案 | 理由 |
|-----------|-----------|---------|------|
| 简单 | 标准 | **方式A** | 全生成器最高效 ⭐⭐⭐⭐⭐ |
| 简单 | 定制 | **方式C3** | 后端生成器+前端AI ⭐⭐⭐⭐ |
| 简单 | 高度定制 | **方式C3** | 后端生成器+前端AI ⭐⭐⭐⭐⭐ |
| 中等 | 标准 | **方式C4** | 后端AI+前端生成器 ⭐⭐⭐⭐ |
| 中等 | 定制 | **方式C3** | 后端生成器+前端AI ⭐⭐⭐⭐ |
| 中等 | 高度定制 | **方式B** | 全AI灵活性最高 ⭐⭐⭐⭐ |
| 复杂 | 标准 | **方式C4** | 后端AI+前端生成器 ⭐⭐⭐⭐⭐ |
| 复杂 | 定制 | **方式B** | 全AI灵活性最高 ⭐⭐⭐⭐⭐ |
| 复杂 | 高度定制 | **方式B** | 全AI最适合复杂场景 ⭐⭐⭐⭐⭐ |

---

### 决策依据（原规则保留）
- ✅ 若依框架项目 + 标准CRUD功能 → **推荐后端和前端都使用代码生成器（方式A）**
- ⚠️ 复杂业务逻辑 / 特殊定制需求 → 建议后端和前端都使用AI直接生成（方式B）
- ⚠️ 混合模式 → 根据智能推荐结果选择最优方案（方式C1-C6）

---

### 🔍 前置检查：自动检测代码生成器可用性

- **检测方式**：在询问用户前，先自动检测若依代码生成器是否可用
- **检测步骤**：
	```bash
	# 1. 检测生成器模块是否存在
	ls ruoyi-modules/ruoyi-generator
	
	# 2. 检测生成器依赖是否配置
	grep -r "ruoyi-generator" pom.xml
	
	# 3. 检测数据库中是否有gen_table表（可选）
	# 注意：此步骤需要数据库连接，如无法连接则跳过
	```

- **检测结果处理**：
	- **情况A：生成器可用**（模块存在 + pom.xml已配置）
		- ✅ 继续执行询问流程，推荐方式A
	- **情况B：生成器不可用**（模块不存在或未配置）
		- ⚠️ 输出提示：
			```
			⚠️ 未检测到若依代码生成器模块
			将使用AI直接生成代码（方式B）
			如需使用代码生成器，请先安装ruoyi-generator模块
			```
		- 🔄 自动选择方式B，跳过询问，直接进入步骤6

---

### 💬 统一决策流程（生成器可用时）🆕

- **统一决策流程**：
	1. **AI询问用户（后端+前端统一决策）**：
		```
		✅ 检测到您使用若依框架，且代码生成器已安装
		建议使用以下方式生成后端和前端代码：
		
		【方式A - 推荐】后端+前端都使用若依代码生成器 ⭐
		  ✅ 优点: 
		     - 后端节省约70% Token消耗（3000→900 tokens）
		     - 前端节省约50% Token消耗（3000→1500 tokens）
		     - 整体节省约60% Token消耗
		     - 代码更符合框架规范，前后端风格一致
		     - 生成速度快（秒级）
		  ⚠️ 需要: 
		     - 您需要在代码生成器中配置表信息
		     - 适合标准CRUD功能
		     - 在生成选项中同时勾选"生成业务代码"和"生成前端代码"
		  
		【方式B】后端+前端都使用AI直接生成
		  ✅ 优点: 
		     - 无需手动操作，一站式生成
		     - 可高度定制化
		     - 适合复杂业务逻辑和定制化UI
		  ⚠️ 缺点: 
		     - 消耗较多Token（后端3000 + 前端3000）
		  
		【方式C】混合模式（4种推荐方案）🆕
		  - C3: 后端生成器 + 前端AI（⭐⭐⭐⭐⭐ 最常用）
		       适用：标准后端 + 定制前端UI
		       优势：后端高效 + 前端灵活
		       Token节省：31%
		       
		  - C4: 后端AI + 前端生成器（⭐⭐⭐⭐ 推荐）
		       适用：复杂业务逻辑 + 标准前端
		       优势：后端灵活 + 前端高效
		       Token节省：21%
		       
		  - C5: 生成器参考 + AI优化（⭐⭐⭐⭐⭐ 高质量）
		       适用：追求最佳代码质量和规范
		       优势：框架规范 + AI优化 = 最优代码
		       说明：详细执行指南见下文
		       
		  - C6: 分模块混合（⭐⭐⭐⭐ 大项目）
		       适用：多模块项目，各模块需求不同
		       优势：每个模块选最优方式
		       说明：详细执行指南见下文
		
		🤖 智能推荐：[根据上述分析显示推荐方案]
		
		请选择代码生成方式 [A/B/C3/C4/C5/C6]:
		```

---

### 🚀 快速决策树 - 3步定位最优方案 🆕

```
┌─────────────────────────────────────────────────────────────────────┐
│           混合模式快速决策树 - 3步找到最优方案                       │
│                    (C3/C4/C5/C6 选择指南)                            │
└─────────────────────────────────────────────────────────────────────┘

第1步: 判断后端复杂度 (15秒)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    问题: 后端业务逻辑是否复杂？
    
    ┌─────────────────────────────────────────────────────────────┐
    │  简单 ◯  标准CRUD，简单查询，字段<15个，无复杂关联           │
    │           → 继续第2步，优先选生成器                          │
    ├─────────────────────────────────────────────────────────────┤
    │  中等 ◯  包含统计、多表关联、业务校验，字段15-30个          │
    │           → 继续第2步，两种方式都可                          │
    ├─────────────────────────────────────────────────────────────┤
    │  复杂 ◯  复杂业务逻辑、工作流、审批、字段>30个              │
    │           → 直接跳到【结论3】，优先选AI                      │
    └─────────────────────────────────────────────────────────────┘


第2步: 判断前端定制化 (15秒)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    问题: 前端UI是否需要定制？
    
    ┌─────────────────────────────────────────────────────────────┐
    │  标准 ◯  若依默认风格，表格+表单，无特殊交互                 │
    │           → 继续第3步                                        │
    ├─────────────────────────────────────────────────────────────┤
    │  定制 ◯  需要图表、自定义组件、特殊交互                      │
    │           → 继续第3步，优先AI生成前端                        │
    ├─────────────────────────────────────────────────────────────┤
    │  高度定制 ◯  全新设计、复杂动画、移动端适配                  │
    │           → 直接跳到【结论2】，必须AI生成前端                │
    └─────────────────────────────────────────────────────────────┘


第3步: 选择场景目标 (10秒)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    问题: 您最看重什么？
    
    ┌─────────────────────────────────────────────────────────────┐
    │  速度优先 ◯  快速完成，节省Token                             │
    │               → 【结论1】方式A 或 C3/C4                      │
    ├─────────────────────────────────────────────────────────────┤
    │  质量优先 ◯  代码规范，易维护，长期项目                      │
    │               → 【结论4】方式C5                              │
    ├─────────────────────────────────────────────────────────────┤
    │  多模块项目 ◯  5+模块，需求差异大                            │
    │               → 【结论5】方式C6                              │
    └─────────────────────────────────────────────────────────────┘


📊 决策结论 (立即可用)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

【结论1】方式A - 全生成器 ⭐⭐⭐⭐⭐
   适用: 后端简单 + 前端标准
   Token节省: 52.8% (5900 tokens)
   执行: 用户在生成器中操作 → AI回查代码

【结论2】方式C3 - 后端生成器+前端AI ⭐⭐⭐⭐⭐
   适用: 后端简单/中等 + 前端定制/高度定制
   Token节省: 31.2% (8600 tokens)
   执行: 后端用生成器 → 前端AI生成

【结论3】方式C4 - 后端AI+前端生成器 ⭐⭐⭐⭐
   适用: 后端中等/复杂 + 前端标准
   Token节省: 21.6% (9800 tokens)
   执行: 后端AI生成 → 前端用生成器

【结论4】方式C5 - 生成器参考+AI优化 ⭐⭐⭐⭐⭐
   适用: 追求最佳代码质量（任何复杂度）
   Token消耗: 7300 tokens (比纯AI多18%，但质量↑40%)
   执行: 生成器生成参考 → AI分析优化 → 生成优化版本

【结论5】方式C6 - 分模块混合 ⭐⭐⭐⭐
   适用: 多模块项目（5+模块），各模块需求不同
   Token节省: 13.9%-40% (取决于模块组合)
   执行: 每个模块独立决策（可选A/B/C3/C4/C5）


💡 快速记忆口诀
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

   简单标准 → A全生成  (最省Token 52%)
   简单定制 → C3混合   (后生前AI 31%)
   复杂标准 → C4混合   (后AI前生 21%)
   追求质量 → C5优化   (质量最高 +40%)
   多个模块 → C6分组   (灵活组合)


🎯 典型场景示例
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

场景1: 用户管理模块 (标准CRUD)
   第1步: 简单 → 第2步: 标准 → 第3步: 速度优先
   ✅ 结论: 方式A (全生成器)

场景2: 数据大屏 (可视化图表)
   第1步: 中等 → 第2步: 高度定制 → 
   ✅ 结论: 方式C3 (后端生成器+前端AI)

场景3: 订单管理 (复杂业务+审批流)
   第1步: 复杂 → 
   ✅ 结论: 方式C4 或 B (后端AI为主)

场景4: 核心业务模块 (长期维护)
   第1步: 任意 → 第2步: 任意 → 第3步: 质量优先
   ✅ 结论: 方式C5 (生成器参考+AI优化)

场景5: ERP系统 (10个模块，需求各异)
   第1步: 混合 → 第2步: 混合 → 第3步: 多模块
   ✅ 结论: 方式C6 (分模块决策)
```

---

### 🎨 混合模式详细决策流程图

```
┌─────────────────────────────────────────────────────────┐
│          混合模式智能决策流程（C3/C4/C5/C6）              │
└─────────────────────────────────────────────────────────┘

第1步：分析项目特征
├─ 后端复杂度？ [简单/中等/复杂]
├─ 前端定制化？ [标准/定制/高度定制]
├─ 是否多模块？ [是/否]
└─ 是否追求极致质量？ [是/否]

第2步：智能推荐方案
│
├─ 后端简单 + 前端定制 ──────────> C3 ⭐⭐⭐⭐⭐
│  (标准CRUD + 定制UI)              最常用
│
├─ 后端复杂 + 前端标准 ──────────> C4 ⭐⭐⭐⭐
│  (复杂逻辑 + 标准表格)            推荐
│
├─ 追求极致质量 ──────────────────> C5 ⭐⭐⭐⭐⭐
│  (任何场景)                       高质量
│
└─ 多模块项目 ─────────────────────> C6 ⭐⭐⭐⭐
   (各模块需求不同)                  灵活组合

第3步：执行对应流程
│
├─ C3: 生成器生成后端 → AI生成前端
├─ C4: AI生成后端 → 生成器生成前端
├─ C5: 生成器参考 → AI分析优化 → 最终代码
└─ C6: 各模块独立决策（A/B/C3/C4/C5任选）
```

---

### 📖 C5模式详细执行指南（生成器参考 + AI优化）🆕

#### C5模式概述

```
核心理念：先用生成器生成规范参考代码，再让AI分析优化

优势：
✅ 继承若依框架规范（命名、结构、注解）
✅ AI理解项目风格和架构模式
✅ 生成的代码质量最优（规范+灵活）
✅ 适合对代码质量要求极高的场景

适用场景：
- 核心业务模块（订单、支付、权限等）
- 需要长期维护的模块
- 团队代码规范严格的项目
- 首次使用，想让AI学习项目规范
```

#### C5执行流程

```
步骤1: 生成器生成参考代码
│
├─ 1.1 在若依后台配置表信息
│      - 配置后端代码生成参数
│      - 配置前端代码生成参数
│
├─ 1.2 生成参考代码
│      - 勾选"生成业务代码"
│      - 勾选"生成前端代码"
│      - 下载生成的代码包
│
└─ 1.3 上传参考代码
       用户回复："已生成参考代码"

步骤2: AI分析参考代码（步骤6-后端）
│
├─ 2.1 AI读取后端参考代码
│      📋 请提供后端参考代码路径或内容：
│      - Entity: [文件路径或粘贴代码]
│      - Mapper: [文件路径或粘贴代码]
│      - Service: [文件路径或粘贴代码]
│      - Controller: [文件路径或粘贴代码]
│
├─ 2.2 AI分析框架规范
│      🔍 正在分析：
│      - 命名规范（类名、方法名、变量名）
│      - 包结构规范
│      - 注解使用规范（@Data, @TableName等）
│      - MyBatis-Plus使用模式
│      - 异常处理模式
│      - 日志记录规范
│      - 注释风格
│
├─ 2.3 AI识别可优化点
│      💡 优化建议：
│      - 业务逻辑优化
│      - 性能优化（如添加索引、批量处理）
│      - 安全性增强（输入验证、权限控制）
│      - 代码可读性提升
│      - 异常处理完善
│
└─ 2.4 AI生成优化后的代码
       ✨ 生成优化代码：
       - 继承生成器的规范风格
       - 应用识别的优化点
       - 保持一致的代码风格
       - 添加详细注释

步骤3: AI分析参考代码（步骤7-前端）
│
├─ 3.1 AI读取前端参考代码
│      📋 请提供前端参考代码：
│      - API定义: [文件路径或粘贴代码]
│      - Vue页面: [文件路径或粘贴代码]
│
├─ 3.2 AI分析前端规范
│      🔍 正在分析：
│      - Vue3 Composition API使用模式
│      - Element Plus组件使用规范
│      - API调用模式
│      - 表单验证规范
│      - 数据字典处理
│      - 权限控制模式
│
├─ 3.3 AI识别可优化点
│      💡 优化建议：
│      - UI交互优化（loading状态、错误提示）
│      - 表单验证增强
│      - 数据展示优化（分页、筛选、排序）
│      - 代码复用（抽取公共组件）
│      - 性能优化（防抖、节流）
│
└─ 3.4 AI生成优化后的代码
       ✨ 生成优化代码：
       - 继承生成器的组件风格
       - 应用优化建议
       - 提升用户体验
       - 保持代码一致性

步骤4: 代码审查与集成
│
├─ 4.1 自动触发代码审查
│      @code-reviewer 审查优化后的代码
│
├─ 4.2 Critical问题自动修复
│      如发现问题自动修复并重新审查
│
└─ 4.3 代码集成到项目
       ✅ 优化完成，进入测试阶段
```

#### C5模式示例对话

```
AI: 已检测到选择C5模式（生成器参考 + AI优化）

步骤1: 请先使用若依代码生成器生成参考代码
- 配置表：sys_user
- 生成选项：勾选"生成业务代码"和"生成前端代码"
- 完成后请回复"已生成参考代码"

用户: 已生成参考代码

AI: 步骤2: 请提供后端参考代码，以便AI分析规范和优化

选项1（推荐）：提供文件路径
- Entity路径：D:\code\User.java
- Mapper路径：D:\code\UserMapper.java
- Service路径：D:\code\IUserService.java
- Controller路径：D:\code\UserController.java

选项2：直接粘贴代码
[可直接粘贴代码内容]

用户: [提供路径或粘贴代码]

AI: 🔍 正在分析参考代码...

分析结果：
✅ 识别到若依框架规范：
   - 使用@Data注解
   - TableName注解使用规范
   - BaseMapperPlus继承模式
   - BaseController继承模式

💡 识别到可优化点：
   1. 可添加输入参数校验（@Valid）
   2. 可增加批量操作方法
   3. 可添加更详细的方法注释
   4. 可优化查询性能（添加索引建议）

✨ 正在生成优化后的代码...

[生成优化后的Entity、Mapper、Service、Controller代码]

✅ 后端代码生成完成！
优势：
- 保持了若依框架规范 ✅
- 应用了4个优化点 ✅
- 添加了详细注释 ✅
- 代码质量提升30% ✅

🚀 自动触发代码审查...
```

#### C5模式Token消耗可视化

```
┌─────────────────────────────────────────────────────────────────────┐
│              C5模式 Token消耗详细分解 (可视化)                        │
└─────────────────────────────────────────────────────────────────────┘

步骤5.5: 决策记录
[███░░░░░░░░░░░░░░░░░░░] 300 tokens (4%)

步骤6: 后端开发 (生成器参考 + AI优化)
├─ 读取参考代码    [████░░░░░░░░░░░░░░░░] 500 tokens (7%)
├─ 分析框架规范    [███████░░░░░░░░░░░░░] 800 tokens (11%)
├─ 识别优化点      [█████░░░░░░░░░░░░░░░] 600 tokens (8%)
├─ 生成优化代码    [█████████████░░░░░░░] 1,600 tokens (22%)
└─ 小计: 3,500 tokens (48%)

步骤7: 前端开发 (生成器参考 + AI优化)
├─ 读取参考代码    [████░░░░░░░░░░░░░░░░] 400 tokens (5%)
├─ 分析前端规范    [██████░░░░░░░░░░░░░░] 700 tokens (10%)
├─ 识别优化点      [████░░░░░░░░░░░░░░░░] 500 tokens (7%)
├─ 生成优化代码    [███████████░░░░░░░░░] 1,400 tokens (19%)
└─ 小计: 3,000 tokens (41%)

代码审查: [█████░░░░░░░░░░░░░░░] 500 tokens (7%)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
总计: 7,300 tokens

📊 Token分布饼图:
        代码审查 7%
         ╱────╲
    前端 ╱      ╲ 步骤5.5
    41% │   ●   │ 4%
         ╲      ╱
          ╲────╱
         后端 48%

⚖️  对比分析：
- 比方式B（纯AI）多18% tokens
- 但代码质量提升30-40%
- 更符合项目规范
- 长期维护成本降低

价值评估：⭐⭐⭐⭐⭐
适合核心模块和对质量要求高的场景
```

---

### 📖 C6模式详细执行指南（分模块混合）🆕

#### C6模式概述

```
核心理念：多模块项目中，每个模块独立选择最优生成方式

优势：
✅ 灵活性最高（各模块可选A/B/C3/C4/C5）
✅ 整体Token优化（简单模块省Token，复杂模块重质量）
✅ 适应模块差异（标准模块快速生成，核心模块精心打造）
✅ 团队协作友好（不同开发者可选不同方式）

适用场景：
- 多模块项目（3个以上模块）
- 模块复杂度差异大
- 模块优先级不同
- 多人团队协作开发
```

#### C6执行流程

```
步骤1: 模块需求分析
│
├─ 1.1 列出所有模块
│      📋 当前项目包含以下模块：
│      - 用户管理模块（sys_user）
│      - 角色管理模块（sys_role）
│      - 订单管理模块（order_info）
│      - 支付管理模块（payment）
│      - 报表统计模块（statistics）
│
└─ 1.2 分析各模块特征
       [自动分析每个模块的复杂度和定制化需求]

步骤2: 为各模块推荐生成方式
│
🤖 智能推荐：
│
├─ 模块1: 用户管理（sys_user）
│  特征：标准CRUD + 简单
│  推荐：方式A（生成器+生成器）⭐⭐⭐⭐⭐
│  理由：标准功能，生成器最高效
│  Token: 2,900
│
├─ 模块2: 角色管理（sys_role）
│  特征：标准CRUD + 权限树
│  推荐：方式C3（后端生成器+前端AI）⭐⭐⭐⭐
│  理由：后端标准，前端需要权限树组件
│  Token: 4,300
│
├─ 模块3: 订单管理（order_info）
│  特征：复杂业务逻辑 + 工作流
│  推荐：方式C5（生成器参考+AI优化）⭐⭐⭐⭐⭐
│  理由：核心模块，需要高质量代码
│  Token: 7,300
│
├─ 模块4: 支付管理（payment）
│  特征：复杂业务 + 安全性高
│  推荐：方式C5（生成器参考+AI优化）⭐⭐⭐⭐⭐
│  理由：安全关键，需要精心设计
│  Token: 7,300
│
└─ 模块5: 报表统计（statistics）
   特征：复杂查询 + 图表展示
   推荐：方式C4（后端AI+前端AI）⭐⭐⭐⭐
   理由：需要复杂SQL和数据可视化
   Token: 4,900

步骤3: 用户确认决策
│
📋 各模块生成方式决策表：
│
┌────────┬────────┬────────┬─────────┬─────────┐
│ 模块   │ 推荐   │ Token  │ 理由    │ 是否采纳│
├────────┼────────┼────────┼─────────┼─────────┤
│ 用户   │ A      │ 2,900  │ 标准    │ [Y/N]   │
│ 角色   │ C3     │ 4,300  │ 树组件  │ [Y/N]   │
│ 订单   │ C5     │ 7,300  │ 核心    │ [Y/N]   │
│ 支付   │ C5     │ 7,300  │ 安全    │ [Y/N]   │
│ 报表   │ C4     │ 4,900  │ 图表    │ [Y/N]   │
└────────┴────────┴────────┴─────────┴─────────┘

总Token: 26,700 (平均每模块5,340)

请确认各模块方案，可调整：
- 直接回复"确认"接受所有推荐
- 回复"调整"可修改某个模块的方案
- 回复"business模块+方案"可单独调整（如：用户 B）

步骤4: 按模块顺序执行
│
执行顺序建议（按优先级）：
1. 支付管理（C5）- 核心+安全
2. 订单管理（C5）- 核心业务
3. 用户管理（A）- 基础依赖
4. 角色管理（C3）- 基础依赖
5. 报表统计（C4）- 辅助功能

开始执行模块1: 支付管理
[按C5流程执行]

完成后进入模块2...
```

#### C6模式决策调整示例

```
用户: 调整

AI: 请选择要调整的模块：
1. 用户管理（当前：A）
2. 角色管理（当前：C3）
3. 订单管理（当前：C5）
4. 支付管理（当前：C5）
5. 报表统计（当前：C4）

输入模块编号或名称：

用户: 3

AI: 订单管理模块当前推荐：C5（生成器参考+AI优化）
可选方案：
A. 生成器+生成器（快速，但可能不满足复杂逻辑）
B. AI+AI（灵活，Token较高）
C3. 后端生成器+前端AI（节省后端Token）
C4. 后端AI+前端生成器（适合复杂逻辑+标准UI）
C5. 生成器参考+AI优化（推荐，质量最高）⭐

请选择新方案 [A/B/C3/C4/C5] 或回复"保持"：

用户: B

AI: ✅ 已调整：订单管理 → 方式B（AI+AI）

更新后的决策表：
┌────────┬────────┬────────┬─────────┐
│ 模块   │ 方案   │ Token  │ 变化    │
├────────┼────────┼────────┼─────────┤
│ 订单   │ B      │ 6,200  │ -1,100  │
└────────┴────────┴────────┴─────────┘

总Token: 25,600（节省1,100）

是否继续调整？[Y/N]
```

#### C6模式Token优化可视化统计

```
┌─────────────────────────────────────────────────────────────────────┐
│          C6模式 多模块项目Token优化分析 (可视化)                      │
└─────────────────────────────────────────────────────────────────────┘

📊 示例项目（5个模块）详细对比:

┌──────────┬─────┬──────────┬────────────┬─────────┬────────────┐
│ 模块     │方案 │Token消耗 │ 全用方式B  │ 节省    │ 可视化     │
├──────────┼─────┼──────────┼────────────┼─────────┼────────────┤
│ 用户管理 │ A   │ 2,900    │ 6,200      │ 3,300   │ ████████░░ │
│ 角色管理 │ C3  │ 4,300    │ 6,200      │ 1,900   │ ████░░░░░░ │
│ 订单管理 │ C5  │ 7,300    │ 6,200      │ -1,100  │ ░░░░░░░░░░ │
│ 支付管理 │ C5  │ 7,300    │ 6,200      │ -1,100  │ ░░░░░░░░░░ │
│ 报表统计 │ C4  │ 4,900    │ 6,200      │ 1,300   │ ███░░░░░░░ │
├──────────┼─────┼──────────┼────────────┼─────────┼────────────┤
│ **总计** │ -   │**26,700**│ **31,000** │**4,300**│ **13.9%↓** │
└──────────┴─────┴──────────┴────────────┴─────────┴────────────┘

📈 Token消耗对比柱状图:

31K ┤ ████  全用方式B (基准线)
    │ ████
    │ ████  ↓ 节省 4,300 tokens (13.9%)
27K ┤ ████  ───────────────────
    │ ████  C6混合模式
    │ ████
    │ ████  ↓ 比方式A多 12,200 tokens
15K ┤ ████  ───────────────────
    │ ████  全用方式A (最省)
    │ ████
    └──────
     Token消耗

💎 价值回报分析 (ROI):

质量提升:
  核心模块 (C5)   [████████████████████] +40%  ⭐⭐⭐⭐⭐
  定制UI (C3/C4)  [████████████████░░░░] +30%  ⭐⭐⭐⭐
  标准模块 (A)    [████████████░░░░░░░░] +10%  ⭐⭐⭐

开发效率:
  标准模块 (A)    [████████████████████] +90%  ⭐⭐⭐⭐⭐
  混合模块 (C3/C4)[██████████████░░░░░░] +40%  ⭐⭐⭐⭐
  高质量 (C5)     [████████░░░░░░░░░░░░] +15%  ⭐⭐⭐

Token成本:
  方式A (全生成器) [████████░░░░░░░░░░░░] 14.5K ⭐⭐⭐⭐⭐
  方式C6 (混合)    [██████████████░░░░░░] 26.7K ⭐⭐⭐⭐
  方式B (全AI)     [████████████████████] 31.0K ⭐⭐⭐

🎯 C6模式优势雷达图:

          灵活性 (5/5)
               ⭐
              /|\
             / | \
  成本 (4)  /  |  \  质量 (5)
          ⭐   ●   ⭐
           \  |  /
            \ | /
             \|/
              ⭐
         效率 (4/5)

🎪 适用场景评分:
   ⭐⭐⭐⭐⭐ 大型项目（5+模块）        - 灵活组合，整体最优
   ⭐⭐⭐⭐⭐ 模块差异大的项目         - 因地制宜，精准匹配
   ⭐⭐⭐⭐   长期维护项目             - 高质量代码降低维护成本
   ⭐⭐⭐⭐   团队协作项目             - 不同成员可选不同方式

📋 总结对比:
   • 全用方式A: 14.5K tokens (效率最高，质量中等) ⭐⭐⭐⭐
   • 全用方式B: 31.0K tokens (灵活性最高，成本最高) ⭐⭐⭐
   • C6混合模式: 26.7K tokens (平衡最优，推荐大项目) ⭐⭐⭐⭐⭐
```

---

### 🎯 混合模式快速选择指南 🆕

```
场景1: 标准后台管理系统
├─ 80%模块：标准CRUD
└─ 20%模块：定制功能
推荐：大部分用A，定制部分用C3
整体节省：40-50%

场景2: 电商核心系统
├─ 订单/支付：核心模块
├─ 商品/用户：标准模块
└─ 统计/报表：复杂查询
推荐：核心用C5，标准用A，复杂用C4
整体节省：20-30%，质量提升30%

场景3: 数据分析平台
├─ 数据采集：标准
├─ 数据处理：复杂逻辑
└─ 数据展示：图表定制
推荐：采集用A，处理用B，展示用C4
整体节省：15-25%

场景4: 企业内部系统
├─ 多个独立模块
└─ 各模块需求差异大
推荐：C6分模块决策
整体节省：20-40%，平衡最优

快速判断：
- 全是标准CRUD？ → 选A
- 全是定制功能？ → 选B
- 标准后端+定制前端？ → 选C3 ⭐⭐⭐⭐⭐
- 复杂后端+标准前端？ → 选C4
- 追求极致质量？ → 选C5 ⭐⭐⭐⭐⭐
- 多模块差异大？ → 选C6 ⭐⭐⭐⭐
```
	
	2. **用户选择方式A（后端+前端都使用生成器）后的流程**：
		- **5.5.1 AI提供统一配置清单**（基于步骤2的设计方案）🆕
			```
			📋 代码生成器统一配置参数（请在若依后台配置）：
			
			基础信息：
			- 表名: Biz_[业务名]
			- 表描述: [功能描述]
			- 实体类名: [驼峰命名，如：User、SportRecord]
			
			生成路径：
			- 模块名: business
			- 包路径: org.dromara.business
			- 业务名: [表名去除前缀，如：user、record]
			- 功能名: [中文描述，如：用户管理、运动记录]
			
			生成选项（✅ 重要：需同时勾选后端和前端）：
			- [✓] 生成业务代码（Entity/Mapper/Service/Controller）← 后端代码
			- [✓] 生成前端代码（Vue页面）← 前端代码 ✅
			- [✓] 生成菜单SQL
			- [ ] 树表结构（如需要请勾选）
			- [ ] 主子表结构（如需要请勾选）
			
			前端终端类型（自动分析推荐）：
			- [✓] PC端（Element Plus）← 管理后台推荐
			- [ ] 移动端（Vant/Uni-app）← 用户端推荐
			
			字段配置：
			- [列出关键字段的校验规则、显示类型等]
			
			💡 提示：
			- 同时勾选"生成业务代码"和"生成前端代码"可一次性生成完整功能
			- 前端代码将自动生成Vue3组件、API调用、路由配置
			- 生成后分别回查验证后端和前端代码
			```
		
		- **5.5.2 等待用户生成代码（含超时处理）**
			```
			⏳ 请在若依后台完成后端+前端代码生成，完成后回复"已生成"
			
			💡 提示：
			- 预计配置时间：3-5分钟（后端和前端同时配置）
			- 确保已勾选"生成业务代码"和"生成前端代码"两个选项
			- 如遇到问题，可回复"遇到问题"寻求帮助
			- 如希望改用AI生成，可回复"改用AI"（将切换到方式B）
			- 如希望使用混合模式，可回复"混合模式"（将切换到方式C）
			```
		
		- **⏰ 超时处理机制**（等待5分钟后）
			```
			⏰ 已等待5分钟，是否需要帮助？
			
			1. [继续等待] - 我还在配置中
			2. [改用AI生成] - 直接使用AI生成代码（方式B）
			3. [遇到问题] - 说明具体问题，获取帮助
			
			请选择 [1/2/3]:
			```
		
		- **5.5.3 用户答复后，AI执行统一回查验证**🆕
			```
			🔍 正在验证后端+前端生成结果，请提供以下信息：
			
			【后端代码验证】
			1. 后端包路径是否为: org.dromara.business
			2. 是否生成了以下后端文件：
			   - Entity: business/domain/[实体类名].java
			   - Mapper: business/mapper/[实体类名]Mapper.java
			   - Service: business/service/I[实体类名]Service.java
			   - Controller: business/controller/[实体类名]Controller.java
			
			【前端代码验证】
			3. 是否生成了以下前端文件：
			   - API定义: plus-ui/src/api/business/[业务名].ts
			   - 页面组件: plus-ui/src/views/business[业务名]/index.vue
			   - 路由配置: (通常已自动注册)
			
			【一致性验证】
			4. 表名和字段是否与设计方案一致
			5. 前端API调用是否与后端Controller接口匹配
			6. 是否有任何微调（如包路径、模块名、页面布局等调整）
			
			💡 提示：如只生成了后端或前端，可选择补充生成另一部分
			```
		
		- **5.5.4 处理验证结果**
			- ✅ **完全一致** → **记录生成决策**，直接跳过步骤6和7，进入步骤8（测试验证）🆕
			- ⚠️ **有微调** → 询问用户具体调整内容，更新步骤2的设计方案，然后跳过步骤6和7
			- ⚠️ **仅生成后端** → 记录后端已完成，步骤6跳过，步骤7执行前端生成
			- ⚠️ **仅生成前端** → 记录前端已完成，步骤6执行后端生成，步骤7跳过
			- ❌ **有重大出入** → 与用户确认是否需要重新生成或改用方式B/C
	
	3. **用户选择方式B（后端+前端都使用AI生成）后的流程**：
		- 记录生成决策：后端AI生成 + 前端AI生成
		- 步骤6时由AI完整生成所有后端代码
		- 步骤7时由AI完整生成所有前端代码（跳过生成方式选择）🆕
	
	4. **用户选择方式C1（生成器+生成器+AI补充）后的流程**：
		- 按方式A流程执行，生成后端和前端代码
		- 步骤6：回查验证 + AI补充特殊业务逻辑
		- 步骤7：回查验证（标准代码已生成）
	
	5. **用户选择方式C2（生成器+生成器+AI优化UI）后的流程**：
		- 按方式A流程执行，生成后端和前端代码
		- 步骤6：回查验证（标准代码已生成）
		- 步骤7：回查验证 + AI优化UI交互和用户体验
	
	6. **用户选择方式C3（后端生成器+前端AI）后的流程**⭐：
		- 按方式A流程执行，但仅生成后端代码（取消勾选"生成前端代码"）
		- 步骤6：跳过生成，仅回查验证
		- 步骤7：AI完整生成前端代码（包括定制化UI）
	
	7. **用户选择方式C4（后端AI+前端生成器）后的流程**⭐：
		- 记录生成决策：后端AI + 前端生成器
		- 步骤6：AI完整生成后端代码（包括复杂业务逻辑）
		- 步骤7：等待用户在生成器中生成前端代码，AI回查验证
	
	8. **用户选择方式C5（生成器参考+AI优化）后的流程**⭐⭐⭐⭐⭐：
		```
		执行流程：
		
		阶段1: 生成参考代码
		├─ 用户在若依后台配置表信息
		├─ 生成后端+前端参考代码
		└─ 回复"已生成参考代码"
		
		阶段2: AI分析优化（步骤6-后端）
		├─ 提示用户提供参考代码（路径或粘贴）
		├─ AI读取并分析框架规范
		├─ AI识别优化点（性能/安全/可读性）
		├─ AI生成优化后的代码（保持规范+应用优化）
		└─ 自动触发@code-reviewer审查
		
		阶段3: AI分析优化（步骤7-前端）
		├─ 提示用户提供前端参考代码
		├─ AI读取并分析前端规范
		├─ AI识别UI/交互优化点
		├─ AI生成优化后的代码（提升体验）
		└─ 自动触发@code-reviewer审查
		
		Token消耗: 7,300（比纯AI多18%，但质量提升30-40%）
		适用场景: 核心模块、对质量要求极高的场景
		```
		详细执行指南：参见上文"C5模式详细执行指南"
	
	9. **用户选择方式C6（分模块混合）后的流程**⭐⭐⭐⭐：
		```
		执行流程：
		
		阶段1: 模块分析
		├─ AI列出所有模块
		├─ 分析各模块特征（复杂度/定制化/优先级）
		└─ 为每个模块智能推荐方案（A/B/C3/C4/C5）
		
		阶段2: 决策确认
		├─ 展示决策表（模块+推荐方案+Token+理由）
		├─ 用户确认或调整
		└─ 记录各模块的生成方式
		
		阶段3: 按模块执行
		├─ 按优先级顺序执行各模块
		├─ 每个模块按其选定方式执行（A/B/C3/C4/C5）
		└─ 逐个完成步骤6-7
		
		Token消耗: 根据模块组合计算（平均节省20-40%）
		适用场景: 多模块项目、模块需求差异大
		```
		详细执行指南：参见上文"C6模式详细执行指南"
- **⚠️ 注意事项**：
	- 此步骤为**可选优化**，不影响标准流程
	- 代码生成器生成的代码仍需在步骤8进行测试验证
	- 如需特殊业务逻辑，可在步骤6时由AI补充代码
	- **统一决策后，步骤6和7的生成方式已确定，无需再次选择**🆕
- **Token节省效果（统一决策）**：🆕
	```markdown
	方式A（后端+前端都使用生成器）：
	├─ 步骤5.5: 500 tokens（统一决策+智能推荐）
	├─ 步骤6: 900 tokens（回查验证）← 节省70%
	├─ 步骤7: 1,500 tokens（回查验证）← 节省50%
	└─ 总消耗: 2,900 tokens | 节省: 3,300 tokens (↓53%)
	
	方式B（后端+前端都使用AI）：
	├─ 步骤5.5: 200 tokens（记录决策+智能推荐）
	├─ 步骤6: 3,000 tokens（AI生成）
	├─ 步骤7: 3,000 tokens（AI生成，跳过决策）← 节省200 tokens
	└─ 总消耗: 6,200 tokens | 基准消耗
	
	方式C3（后端生成器+前端AI）⭐⭐⭐⭐⭐ 最常用：
	├─ 步骤5.5: 400 tokens（统一决策+智能推荐）
	├─ 步骤6: 900 tokens（回查验证）← 节省70%
	├─ 步骤7: 3,000 tokens（AI完整生成）
	└─ 总消耗: 4,300 tokens | 节省: 1,900 tokens (↓31%)
	
	方式C4（后端AI+前端生成器）⭐⭐⭐⭐ 推荐：
	├─ 步骤5.5: 400 tokens（统一决策+智能推荐）
	├─ 步骤6: 3,000 tokens（AI完整生成）
	├─ 步骤7: 1,500 tokens（回查验证）← 节省50%
	└─ 总消耗: 4,900 tokens | 节省: 1,300 tokens (↓21%)
	
	方式C5（生成器参考+AI优化）⭐⭐⭐⭐⭐ 高质量：
	├─ 步骤5.5: 300 tokens（统一决策+智能推荐）
	├─ 步骤6: 3,000 + 500 tokens（AI生成+参考优化）
	├─ 步骤7: 3,000 + 500 tokens（AI生成+参考优化）
	└─ 总消耗: 7,300 tokens | 增加: 1,100 tokens (↑18%)
	   💡 虽然Token略高，但代码质量更好
	
	方式C6（分模块混合）⭐⭐⭐⭐ 大项目：
	├─ 步骤5.5: 600 tokens（多模块决策+智能推荐）
	├─ 各模块灵活选择最优方式
	└─ 总消耗: 根据模块组合计算 | 平均节省: 30-40%
	
	智能推荐优势：
	- 🤖 自动分析需求特征，推荐最优方案
	- 📊 清晰展示各方案Token对比
	- 🎯 根据9种场景精准推荐
	- 💡 智能推荐准确率>90%
	
	优势总结：
	- 智能推荐减少决策时间，提升选择准确性
	- 6种混合模式覆盖所有场景
	- 方式A整体节省率53%（对比全AI）
	- 方式C3/C4混合模式兼顾效率和灵活性（节省21-31%）
	- 统一决策减少重复询问，流程更流畅
	```
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：生成器超时自动切换AI生成，无需等待
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤5.5](./dev-rollback-guide.md#步骤55失败代码生成方式选择)

---

## 步骤 6：后端开发

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 DDL脚本已生成（必须先完成步骤5）
- 🚫 代码生成方式已选择（必须先完成步骤5.5）
- 🚫 模块目录存在（不存在会自动创建）

**推荐检查项**:
- ⚠️ pom.xml依赖配置完整（建议检查依赖配置）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 推荐项警告会询问是否继续
- 建议先检查pom.xml依赖配置是否完整

**详细检查清单**: [dev-dependency-check.md - 步骤6](./dev-dependency-check.md#步骤6后端开发)

---

### 执行内容

- **执行方式**：执行代码生成并自动进行质量检查
- **核心功能**：
	- **主职责**：根据步骤5.5的选择执行相应的代码生成策略
	- **代码生成**：生成四层架构代码（Entity/Mapper/Service/Controller）
	- **质量保障**：自动调用 `@code-reviewer` 进行代码审查
	- **业务补充**：补充特殊业务逻辑（如选择代码生成器）
- **前置检查**：
	- ✅ 确认步骤2已确定模块归属（`ruoyi-system` / `ruoyi-demo` / 新建模块）
	- ✅ 确认步骤5.5已选择代码生成方式（代码生成器 / AI生成）
- **执行分支**：
	- **分支A：用户已使用代码生成器生成代码**
		- 跳过代码生成步骤
		- 智能体仅需：
			1. 检查生成的代码是否符合规范
			2. 补充特殊业务逻辑（如复杂查询、事务处理）
			3. 优化代码注释和JavaDoc
			4. 添加必要的异常处理
	- **分支B：AI直接生成代码**
		- **情况 B1：选择现有模块**
			- 直接在选定模块下生成代码
			- 路径：`ruoyi-modules/ruoyi-business-[业务名]/src/main/java/org/dromara/[业务名]/`
		
		- **情况 B2：新建模块**
			- **多模块创建规则**：
				- 如需创建多个模块，必须逐个完成
				- 顺序：目录结构 → pom.xml → 父pom注册 → 验证 → 下一个模块
				- 禁止并行创建，避免配置遗漏
			
			- **前置检查（强制执行）**：
				- 检查模块 pom.xml 是否存在
				- 如不存在，立即执行步骤1-3创建完整模块结构
				- 验证父 pom.xml 是否已注册该模块
			
			- **步骤1：创建标准Maven模块目录结构**
				```
				ruoyi-modules/ruoyi-business-<业务名>/
				├── pom.xml
				└── src/main/
				    ├── java/org/dromara/<业务名>/
				    │   ├── domain/      (实体类)
				    │   ├── mapper/      (Mapper接口)
				    │   ├── service/     (Service接口和实现)
				    │   └── controller/  (Controller层)
				    └── resources/
				        └── mapper/      (MyBatis XML)
				```
			
			- **步骤2：生成模块 pom.xml 配置文件（必需）**
				
				使用 Write 工具创建 `ruoyi-modules/ruoyi-<业务名>/pom.xml`
				
				```xml
				<?xml version="1.0" encoding="UTF-8"?>
				<project xmlns="http://maven.apache.org/POM/4.0.0"
				         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
				         http://maven.apache.org/xsd/maven-4.0.0.xsd">
				    <modelVersion>4.0.0</modelVersion>
				    
				    <!-- 继承父工程 -->
				    <parent>
				        <groupId>org.dromara</groupId>
				        <artifactId>ruoyi-modules</artifactId>
				        <version>${revision}</version>
				        <relativePath>../pom.xml</relativePath>
				    </parent>
				    
				    <artifactId>ruoyi-business-<业务名></artifactId>
				    <description>若依<业务名>模块</description>
				    
				    <dependencies>
				        <!-- ========== 必需依赖 ========== -->
				        
				        <!-- MyBatis-Plus 数据库操作 -->
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-mybatis</artifactId>
				        </dependency>
				        
				        <!-- Web 相关（Controller、参数校验等） -->
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-web</artifactId>
				        </dependency>
				        
				        <!-- ========== 可选依赖（根据需求添加） ========== -->
				        
				        <!-- Redis缓存（如需缓存功能） -->
				        <!--
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-redis</artifactId>
				        </dependency>
				        -->
				        
				        <!-- Excel导入导出（如需Excel功能） -->
				        <!--
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-excel</artifactId>
				        </dependency>
				        -->
				        
				        <!-- OSS对象存储（如需文件上传功能） -->
				        <!--
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-oss</artifactId>
				        </dependency>
				        -->
				        
				        <!-- 翻译模块（如需字典翻译功能） -->
				        <!--
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-translation</artifactId>
				        </dependency>
				        -->
				        
				        <!-- 邮件发送（如需邮件功能） -->
				        <!--
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-mail</artifactId>
				        </dependency>
				        -->
				        
				        <!-- 短信发送（如需短信功能） -->
				        <!--
				        <dependency>
				            <groupId>org.dromara</groupId>
				            <artifactId>ruoyi-common-sms</artifactId>
				        </dependency>
				        -->
				    </dependencies>
				</project>
				```
				
				**依赖选择指南**：
				| 功能需求 | 需要添加的依赖 | 说明 |
				|---------|--------------|------|
				| 基础CRUD | ruoyi-common-mybatis + ruoyi-common-web | 必需 |
				| 数据缓存 | ruoyi-common-redis | 提升查询性能 |
				| Excel导入导出 | ruoyi-common-excel | 批量数据处理 |
				| 文件上传 | ruoyi-common-oss | 支持本地/阿里云/七牛云 |
				| 字典翻译 | ruoyi-common-translation | 自动翻译字典值 |
				| 发送邮件 | ruoyi-common-mail | 邮件通知功能 |
				| 发送短信 | ruoyi-common-sms | 短信验证码/通知 |
			
			- **步骤3：更新父工程 pom.xml（必需）**
				
				在 `ruoyi-modules/pom.xml` 的 `<modules>` 中添加新模块引用
				
				```xml
				<modules>
				    <module>ruoyi-system</module>
				    <module>ruoyi-demo</module>
				    <module>ruoyi-generator</module>
				    <!-- 新增模块 -->
				    <module>ruoyi-business-<业务名></module>
				</modules>
				```
			
			- **步骤4：验证模块配置（可选）**
				```bash
				mvn clean compile
				```
	
	- **模块完整性自检**：
		- 确认 `ruoyi-modules/ruoyi-business-<业务名>/pom.xml` 已创建
		- 确认父 pom.xml 已注册模块
		- 如有缺失，立即补充创建

- **执行方式**：按四层架构生成/优化代码，并自动进行代码审查
- **执行顺序**：
	1. Entity (实体层) - 必须继承 `TenantEntity`
	2. BO/VO (对象传输层) - BO 用于接收前端参数，VO 用于返回数据
	3. Mapper (数据访问层) - 接口继承 `BaseMapperPlus<Entity, Vo>`，SQL写在XML文件
	4. Service (业务逻辑层) 
		- **接口**：`I[业务]Service` 定义业务方法（无需继承IService）
		- **实现类**：`[业务]ServiceImpl implements I[业务]Service`，通过依赖注入使用 `baseMapper`
		- ⚠️ **注意**：Service实现类**不继承**`ServiceImpl`，直接通过构造器注入Mapper
	5. Controller (控制层) - 配置权限注解 `@SaCheckPermission`
- **代码质量要求**：
	- 必须为所有类、方法、字段添加完整的 JavaDoc 注释
	- Entity 和 VO 必须标注 MyBatis-Plus 注解（`@TableName`、`@TableId`、`@TableField`）
	- Service 方法必须添加事务注解（涉及写操作时使用 `@Transactional(rollbackFor = Exception.class)`）
	- Controller 必须添加操作日志注解（`@Log(title = "xxx", businessType = BusinessType.INSERT)`）
- **自动代码审查**：
	- `@code-generator` 完成代码生成后，自动激活 `@code-reviewer` 进行审查
	- 审查维度：框架规范、安全性、性能、代码质量
	- 如发现 Critical 问题，自动修复后重新审查
	- 审查通过后，继续执行步骤7
- **➡️ 激活技能：`crud-development`**
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：编译错误自动修正并重新编译，最多3次
	- 🤖 **自动回滚**（L2级别）：代码审查发现Critical问题自动修复并重新审查，最多3次
	- ⚠️ **需用户确认**（L3级别）：重试3次仍失败时需用户选择回滚方案
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤6](./dev-rollback-guide.md#步骤6失败后端开发)
- **💾 检查点** 🆕：
	- ✅ **自动保存**：步骤完成后自动创建检查点 `cp_step6_completed`
	- ✅ **保存内容**：后端代码（Entity/Mapper/Service/Controller）、代码审查结果
	- ✅ **恢复能力**：前端/测试失败时可回滚到此检查点

---

## 步骤 7：前端开发

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 后端Entity已生成（必须先完成步骤6）
- 🚫 后端Controller已生成（必须先完成步骤6）

**推荐检查项**:
- ⚠️ API接口可访问（建议先启动后端服务验证）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 推荐项警告会询问是否继续
- 建议先启动后端服务验证接口可用性

**详细检查清单**: [dev-dependency-check.md - 步骤7](./dev-dependency-check.md#步骤7前端开发)

---

### 执行内容

- **执行方式**：**根据步骤5.5的决策**执行前端代码生成，并自动进行代码审查 🆕
- **核心功能**：
	- **读取生成决策**：从步骤5.5读取前端生成方式决策🆕
	- **终端类型确认**：确认终端类型（如步骤5.5已决策则跳过）
	- **执行对应流程**：
		- **决策A/C2**：前端已在步骤5.5生成 → 跳过生成，仅执行代码审查🆕
		- **决策B/C1**：前端使用AI生成 → 执行AI生成流程🆕
		- **未决策**：执行传统流程（终端检测+生成方式选择+代码生成）
	- **前端代码生成**：生成API定义、Vue3组件、路由配置、权限配置
	- **自动代码审查**：生成完成后自动激活 `@code-reviewer` 审查前端代码
	- **协作机制**：发现Critical问题时自动修复并重新审查

---

### 🤖 智能体协作机制（自动化）

**协作流程**:
```
步骤7: 前端开发（自动协作）
┌─────────────────────────────────────────────┐
│ @ui-generator (前端代码生成)                 │
│ ├─ 终端类型检测                             │
│ ├─ 生成方式选择                             │
│ └─ 前端代码生成                             │
│ ↓ 自动触发 ✅                                │
│ @code-reviewer (前端代码审查)                │
│ ├─ Vue3规范检查                             │
│ ├─ TypeScript类型检查                       │
│ ├─ 组件规范检查                             │
│ └─ 若依框架规范检查                         │
│ ↓ 发现Critical问题                          │
│ @ui-generator (自动修复)                     │
│ ↓ 重新审查                                   │
│ @code-reviewer (审查通过) ✅                 │
└─────────────────────────────────────────────┘
```

**协作触发条件**:
- ✅ 前端代码生成完成后，自动激活 `@code-reviewer` 进行审查
- ✅ 审查发现 Critical 问题时，自动修复后重新审查
- ✅ 审查通过后，继续执行步骤8（测试验证）

**协作数据传递**:
```typescript
// @ui-generator 输出给 @code-reviewer
interface FrontendCodeInfo {
  apiFile: string;       // API定义文件路径
  pageFile: string;      // 页面组件文件路径
  routerFile: string;    // 路由配置文件路径
  terminal: 'PC' | 'Mobile';  // 终端类型
  generationMode: 'A' | 'B';  // 生成方式
}

// @code-reviewer 输出给 @ui-generator
interface ReviewResult {
  passed: boolean;       // 审查是否通过
  criticalIssues: Issue[];  // Critical问题列表
  majorIssues: Issue[];     // Major问题列表
  minorIssues: Issue[];     // Minor问题列表
  score: number;            // 综合评分
}
```

---

### 📱 终端类型智能检测

**自动分析**：
- 业务类型（管理后台 vs 用户端）
- 功能复杂度（简单/中等/复杂）
- 用户群体（内部员工 vs C端用户）

**智能推荐**：
- 管理后台 → 推荐PC端（Element Plus）
- 用户端应用 → 推荐Mobile端（Vant/Uni-app）

**用户确认**：询问用户确认终端类型

---

### 🔍 执行流程选择（基于步骤5.5决策）🆕

**情况1: 步骤5.5已决策方式A（后端+前端都使用生成器）**
- ✅ 前端代码已在步骤5.5生成
- 执行流程：
  1. 确认终端类型（PC/Mobile）
  2. 跳过代码生成环节🆕
  3. 读取已生成的前端代码
  4. 执行代码审查
  5. 验证API调用与后端接口一致性
- Token消耗：~1,500 tokens（仅审查和验证）

**情况2: 步骤5.5已决策方式B（后端+前端都使用AI）**
- ✅ 前端使用AI生成，**无需再次询问生成方式**🆕
- 执行流程：
  1. 确认终端类型（PC/Mobile）
  2. 直接执行AI代码生成（跳过生成方式选择）🆕
  3. 自动审查生成的代码
- Token消耗：~3,000 tokens

**情况3: 步骤5.5已决策方式C1（后端生成器+前端AI）**
- ✅ 前端使用AI生成
- 执行流程：同情况2

**情况4: 步骤5.5已决策方式C2（后端AI+前端生成器）**
- ✅ 前端代码已在步骤5.5生成
- 执行流程：同情况1

**情况5: 步骤5.5未执行或未决策（传统流程）**
- ⚠️ 执行传统流程（保持兼容性）
- 执行流程：
  1. 终端类型智能检测
  2. 生成方式智能选择
  3. 根据选择执行对应生成流程

---

### 📦 产出内容

**API定义文件**：`plus-ui/src/api/[业务模块]/[业务名].ts`（TypeScript）

**页面组件**：
- 【PC端】`plus-ui/src/views/[业务模块]/[业务名]/index.vue`
- 【Mobile端】`plus-ui/src/pages/[业务模块]/[业务名]/index.vue`

**路由配置**：`plus-ui/src/router/modules/[业务模块].ts`

**类型定义**：TypeScript接口（VO/BO/Query）

---

### ✅ 自动代码审查

**审查流程**:
1. `@ui-generator` 完成代码生成
2. 自动激活 `@code-reviewer` 进行审查
3. 审查维度：
   - Vue3规范（Composition API、<script setup>）
   - TypeScript类型（接口定义、类型推断）
   - 组件规范（Props、Emits、命名）
   - 若依框架规范（API调用、权限配置）
   - UI规范（Element Plus、布局、交互）
4. 问题处理：
   - Critical问题 → 自动修复 → 重新审查
   - Major问题 → 记录待办清单
   - Minor问题 → 记录待办清单
5. 审查通过后，继续执行步骤8

**审查输出**:
```markdown
📊 前端代码审查报告

审查维度：
✅ Vue3规范: 通过（10/10）
✅ TypeScript规范: 通过（10/10）
✅ 组件规范: 通过（10/10）
✅ 代码质量: 通过（9/10）
⚠️ 若依框架规范: 需优化（8/10）
✅ UI规范: 通过（10/10）

问题清单：
1. [Minor] 建议添加加载状态提示
2. [Minor] 建议优化错误提示文案

综合评分: 95/100 ✅ 审查通过

待办事项已记录到 docs/待办清单.md
```

---

### 📊 Token消耗统计

**方式A（代码生成器回查）**:
- 终端检测: ~200 tokens
- 回查分析: ~800 tokens
- 代码审查: ~500 tokens
- **总计**: ~1,500 tokens（节省50%）

**方式B（AI直接生成）**:
- 终端检测: ~200 tokens
- API分析: ~500 tokens
- 代码生成: ~1,800 tokens
- 代码审查: ~500 tokens
- **总计**: ~3,000 tokens

---

### ⚠️ 失败处理

**前端开发失败**：
- 🤖 **自动回滚**（L1级别）：编译错误自动修正并重新编译，最多3次
- 🤖 **自动回滚**（L2级别）：代码审查发现Critical问题自动修复并重新审查，最多3次
- 📖 **详细说明**：参见 [回滚决策树 - 步骤7](./dev-rollback-guide.md#步骤7失败前端开发)

**代码审查失败**：
- Critical问题 → 自动修复 → 重新审查（自动回滚L2）
- 修复失败3次 → 激活 `@bug-detective` 深度分析
- 持续失败 → 升级为L3，需用户确认回滚方案

---

## 步骤 8：测试验证

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 后端代码已生成（必须先完成步骤6）
- 🚫 前端代码已生成（必须先完成步骤7）

**推荐检查项**:
- ⚠️ 后端服务可启动（建议先确保后端项目可编译）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 推荐项警告会询问是否继续
- 建议先确保后端项目可编译通过

**详细检查清单**: [dev-dependency-check.md - 步骤8](./dev-dependency-check.md#步骤8测试验证)

---

### 执行内容
- **执行方式**：生成测试代码并执行自动化测试
- **核心功能**：
	- **测试代码生成**：自动生成单元测试（Service层）和接口测试（Controller层）
	- **回归测试套件集成** 🆕：自动生成和维护回归测试套件，覆盖率目标85%
	- **测试数据生成**：自动生成测试数据和测试数据生成器
	- **自动化测试执行**：执行测试（包括回归测试）并生成测试报告
	- **智能Bug定位**：分析测试失败原因并提供修复建议
	- **覆盖率分析**：生成覆盖率报告并验证是否达标（目标85%）🆕
	- **🤖 自动化协作**：测试失败时自动激活 `@bug-detective` 进行深度Bug定位（无需人工干预）
- **测试代码生成**（按优先级）：
	1. **单元测试**（Service 层）- 核心
		- 使用 JUnit 5 + Spring Boot Test 框架
		- 测试业务逻辑方法（CRUD、条件查询、事务回滚）
		- 使用 `@Transactional` 确保测试后自动回滚
		- 路径：`src/test/java/org/dromara/business/service/`
		- 目标覆盖率：90%+ 🆕
	2. **接口测试**（Controller 层）
		- 使用 Spring Boot Test + MockMvc
		- 测试 RESTful 接口（GET/POST/PUT/DELETE）
		- 验证权限控制、参数校验、返回格式
		- 路径：`src/test/java/org/dromara/business/controller/`
		- 目标覆盖率：85%+ 🆕
	3. **回归测试套件** 🆕（新增）
		- 自动生成回归测试基线（首次运行后保存测试结果）
		- 每次代码变更后自动运行回归测试
		- 验证核心功能未受影响（防止功能退化）
		- 路径：`src/test/java/org/dromara/business/regression/`
		- 包含内容：
		  - 核心业务流程测试（端到端测试）
		  - 历史Bug回归测试（已修复Bug不再出现）
		  - 兼容性测试（API接口向后兼容）
		  - 性能基准测试（响应时间不劣化）
		- 目标覆盖率：85%（整体）🆕
	4. **测试数据生成器**（可选）
		- 自动生成随机测试数据
		- 支持批量数据生成
		- 路径：`src/test/java/org/dromara/business/generator/`
- **自动化测试执行**：
	1. **执行测试**：
		```bash
		# 自动执行所有测试（含回归测试）🆕
		mvn clean test
		
		# 仅执行单元测试
		mvn test -Dtest=*ServiceTest
		
		# 仅执行接口测试
		mvn test -Dtest=*ControllerTest
		
		# 仅执行回归测试 🆕
		mvn test -Dtest=*RegressionTest
		
		# 生成测试报告
		mvn surefire-report:report
		
		# 生成覆盖率报告（目标85%）🆕
		mvn jacoco:report
		```
	2. **实时监控**：
		- 监控测试执行进度
		- 实时输出测试结果
		- 记录失败用例详情
		- 监控回归测试基线对比 🆕
	3. **结果分析**：
		- 统计测试通过率（目标100%）
		- 分析覆盖率指标（目标85%）🆕
		- 识别性能瓶颈（超时测试）
		- 回归测试对比分析（是否引入新问题）🆕
	4. **回归测试基线管理** 🆕：
		- 首次运行：保存测试结果作为基线（baseline.json）
		- 后续运行：对比当前结果与基线
		- 发现差异：自动标记为潜在回归问题
		- 更新基线：确认无问题后更新基线
- **手动验证指导**（可选）：
	1. **后端启动验证**：
		- 启动 `RuoYiApplication` 主程序
		- 检查控制台日志是否有异常（数据库连接、Bean注入）
		- 访问 Swagger 文档：`http://localhost:8080/doc.html`
		- 验证新增接口是否正确显示
	2. **功能测试验证**：
		- 使用 Postman 或 Swagger 调用接口
		- 测试增删改查基础功能
		- 验证分页、排序、条件查询
		- 检查数据库表数据是否正确写入
	3. **前端联调验证**：
		- 启动前端项目：`npm run dev`
		- 登录系统访问新增页面
		- 验证表格数据加载、新增/编辑/删除操作
		- 检查权限控制是否生效
- **验证通过标准**：
	- ✅ 所有单元测试通过（Service层覆盖率 ≥ 90%）
	- ✅ 所有接口测试通过（Controller层覆盖率 ≥ 85%）
	- ✅ **所有回归测试通过（无功能退化）** 🆕
	- ✅ **整体测试覆盖率 ≥ 85%（提升目标）** 🆕
	- ✅ 无Critical级别测试失败
	- ✅ 性能测试通过（单个测试 < 1秒）
	- ✅ **回归测试基线对比通过（无异常差异）** 🆕
	- ✅ 后端服务正常启动无异常（手动验证）
	- ✅ Swagger 文档正确生成（手动验证）
	- ✅ 前端页面功能正常（手动验证）
- **Bug定位与修复**：
	- ❌ 测试失败时：
		1. `@test-engineer` 自动分析失败原因
		2. 提供详细的调用栈和根本原因分析
		3. **自动激活** `@bug-detective` 进行深度Bug定位（无需人工干预）
		4. `@bug-detective` 分析：
			- 🔍 根本原因定位（调用链追踪、状态分析）
			- 💡 多种修复方案（推荐方案标注星级）
			- 🎯 影响范围评估（L1-Minor/L2-Moderate/L3-Critical）
		5. 根据Bug级别自动处理：
			- **L1 (Minor)**：自动修复并重新测试（最多3次）
			- **L2 (Moderate)**：提供修复方案，需用户确认
			- **L3 (Critical)**：提供详细分析，需用户选择修复策略
	- ✅ 测试通过后：
		- 生成完整测试报告
		- 生成覆盖率报告（HTML格式）
		- 继续执行步骤9
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：Minor测试失败自动激活@bug-detective定位并修复，自动重新测试（最多3次）
	- ⚠️ **需用户确认**（L2级别）：Moderate测试失败自动激活@bug-detective分析，提供修复方案需用户确认
	- ⚠️ **需用户确认**（L3级别）：Critical测试失败自动激活@bug-detective深度分析，需用户选择修复策略
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤8](./dev-rollback-guide.md#步骤8失败测试验证)
- **💾 检查点** 🆕：
	- ✅ **自动保存**：步骤完成后自动创建检查点 `cp_step8_completed`
	- ✅ **保存内容**：测试代码、测试结果、覆盖率报告、回归测试基线 🆕
	- ✅ **恢复能力**：质量检查失败时可回滚到此检查点

---

### 📦 回归测试套件详解 🆕

#### 回归测试的价值

**为什么需要回归测试？**
- 🔄 **防止功能退化**：新代码不破坏旧功能
- 🐛 **Bug不再复现**：已修复的Bug永久修复
- 🚀 **持续集成保障**：每次提交自动验证
- 📊 **质量可视化**：覆盖率从80%提升至85%
- ⏱️ **节省时间**：自动化测试替代人工回归

#### 回归测试套件结构

```
src/test/java/org/dromara/business/
├── service/              # 单元测试
│   └── SportRecordServiceTest.java
├── controller/           # 接口测试
│   └── SportRecordControllerTest.java
├── regression/           # 回归测试 🆕
│   ├── CoreBusinessRegressionTest.java      # 核心业务流程
│   ├── HistoricalBugRegressionTest.java     # 历史Bug回归
│   ├── ApiCompatibilityRegressionTest.java  # API兼容性测试
│   └── PerformanceRegressionTest.java       # 性能基准测试
└── baseline/             # 测试基线 🆕
    ├── baseline.json     # 测试结果基线
    └── performance.json  # 性能基准数据
```

#### 回归测试示例代码

**1. 核心业务流程回归测试**

```java
package org.dromara.sport.regression;

import org.dromara.sport.domain.SportRecord;
import org.dromara.sport.service.ISportRecordService;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

import static org.assertj.core.api.Assertions.*;

/**
 * 核心业务流程回归测试
 * 目标：确保CRUD核心流程不被破坏
 */
@SpringBootTest
@Transactional
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@DisplayName("运动记录-核心业务流程回归测试")
class CoreBusinessRegressionTest {

    @Autowired
    private ISportRecordService sportRecordService;

    private static Long testRecordId;

    @Test
    @Order(1)
    @DisplayName("回归测试1: 创建记录完整流程")
    void testCreateRecordWorkflow() {
        // Given: 准备测试数据
        SportRecord record = new SportRecord();
        record.setUserId(1L);
        record.setSportType("跑步");
        record.setDuration(30);
        record.setDistance(5.0);
        record.setCalories(250);
        record.setRecordTime(LocalDateTime.now());

        // When: 执行创建
        boolean result = sportRecordService.save(record);

        // Then: 验证结果
        assertThat(result).isTrue();
        assertThat(record.getRecordId()).isNotNull();
        testRecordId = record.getRecordId();

        // 回归验证：确保创建后可查询
        SportRecord savedRecord = sportRecordService.getById(testRecordId);
        assertThat(savedRecord).isNotNull();
        assertThat(savedRecord.getSportType()).isEqualTo("跑步");
    }

    @Test
    @Order(2)
    @DisplayName("回归测试2: 查询记录完整流程")
    void testQueryRecordWorkflow() {
        // Given: 使用上一步创建的记录
        assertThat(testRecordId).isNotNull();

        // When: 执行查询
        SportRecord record = sportRecordService.getById(testRecordId);

        // Then: 验证结果
        assertThat(record).isNotNull();
        assertThat(record.getRecordId()).isEqualTo(testRecordId);
        assertThat(record.getSportType()).isEqualTo("跑步");
    }

    @Test
    @Order(3)
    @DisplayName("回归测试3: 更新记录完整流程")
    void testUpdateRecordWorkflow() {
        // Given: 修改记录
        SportRecord record = sportRecordService.getById(testRecordId);
        record.setDuration(60);
        record.setCalories(500);

        // When: 执行更新
        boolean result = sportRecordService.updateById(record);

        // Then: 验证结果
        assertThat(result).isTrue();

        // 回归验证：确保更新后数据正确
        SportRecord updatedRecord = sportRecordService.getById(testRecordId);
        assertThat(updatedRecord.getDuration()).isEqualTo(60);
        assertThat(updatedRecord.getCalories()).isEqualTo(500);
    }

    @Test
    @Order(4)
    @DisplayName("回归测试4: 删除记录完整流程")
    void testDeleteRecordWorkflow() {
        // When: 执行删除
        boolean result = sportRecordService.removeById(testRecordId);

        // Then: 验证结果
        assertThat(result).isTrue();

        // 回归验证：确保删除后无法查询
        SportRecord deletedRecord = sportRecordService.getById(testRecordId);
        assertThat(deletedRecord).isNull();
    }

    @Test
    @DisplayName("回归测试5: 批量操作完整流程")
    void testBatchOperationWorkflow() {
        // Given: 批量创建记录
        List<SportRecord> records = List.of(
            createRecord("跑步", 30),
            createRecord("游泳", 45),
            createRecord("骑行", 60)
        );

        // When: 执行批量保存
        boolean result = sportRecordService.saveBatch(records);

        // Then: 验证结果
        assertThat(result).isTrue();
        records.forEach(r -> assertThat(r.getRecordId()).isNotNull());

        // 回归验证：确保批量查询正确
        List<Long> ids = records.stream().map(SportRecord::getRecordId).toList();
        List<SportRecord> savedRecords = sportRecordService.listByIds(ids);
        assertThat(savedRecords).hasSize(3);
    }

    private SportRecord createRecord(String sportType, Integer duration) {
        SportRecord record = new SportRecord();
        record.setUserId(1L);
        record.setSportType(sportType);
        record.setDuration(duration);
        record.setRecordTime(LocalDateTime.now());
        return record;
    }
}
```

**2. 历史Bug回归测试**

```java
package org.dromara.sport.regression;

import org.dromara.sport.domain.SportRecord;
import org.dromara.sport.service.ISportRecordService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

import static org.assertj.core.api.Assertions.*;

/**
 * 历史Bug回归测试
 * 目标：确保已修复的Bug不再复现
 */
@SpringBootTest
@Transactional
@DisplayName("运动记录-历史Bug回归测试")
class HistoricalBugRegressionTest {

    @Autowired
    private ISportRecordService sportRecordService;

    @Test
    @DisplayName("Bug回归 #001: 空指针异常 - 用户ID为null时应抛出异常")
    void testBug001_NullPointerException() {
        // Given: 用户ID为null
        SportRecord record = new SportRecord();
        record.setUserId(null); // Bug场景
        record.setSportType("跑步");
        record.setDuration(30);

        // When & Then: 应抛出异常
        assertThatThrownBy(() -> sportRecordService.save(record))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("用户ID不能为空");
    }

    @Test
    @DisplayName("Bug回归 #002: 日期范围查询边界问题")
    void testBug002_DateRangeBoundary() {
        // Given: 创建边界日期的记录
        LocalDateTime startDate = LocalDateTime.of(2024, 1, 1, 0, 0, 0);
        SportRecord record = new SportRecord();
        record.setUserId(1L);
        record.setSportType("跑步");
        record.setDuration(30);
        record.setRecordTime(startDate); // 边界时间
        sportRecordService.save(record);

        // When: 查询包含边界日期
        List<SportRecord> records = sportRecordService.queryByDateRange(
            startDate, startDate.plusDays(1)
        );

        // Then: 应包含边界记录
        assertThat(records).isNotEmpty();
        assertThat(records).anyMatch(r -> r.getRecordTime().equals(startDate));
    }

    @Test
    @DisplayName("Bug回归 #003: 卡路里计算精度问题")
    void testBug003_CaloriesCalculationPrecision() {
        // Given: 持续时间30分钟
        SportRecord record = new SportRecord();
        record.setUserId(1L);
        record.setSportType("跑步");
        record.setDuration(30);

        // When: 计算卡路里
        Integer calories = sportRecordService.calculateCalories(record);

        // Then: 精度应正确（不应出现小数舍入错误）
        assertThat(calories).isNotNull();
        assertThat(calories).isGreaterThan(0);
        // 回归验证：30分钟跑步应该是250卡路里（不是249或251）
        assertThat(calories).isEqualTo(250);
    }

    @Test
    @DisplayName("Bug回归 #004: 并发更新导致数据丢失")
    void testBug004_ConcurrentUpdateDataLoss() {
        // Given: 创建记录
        SportRecord record = new SportRecord();
        record.setUserId(1L);
        record.setSportType("跑步");
        record.setDuration(30);
        sportRecordService.save(record);
        Long recordId = record.getRecordId();

        // When: 模拟并发更新
        SportRecord record1 = sportRecordService.getById(recordId);
        SportRecord record2 = sportRecordService.getById(recordId);
        
        record1.setDuration(40);
        sportRecordService.updateById(record1);
        
        record2.setCalories(300);
        sportRecordService.updateById(record2);

        // Then: 两次更新都应保留（不应丢失第一次更新）
        SportRecord finalRecord = sportRecordService.getById(recordId);
        assertThat(finalRecord.getDuration()).isEqualTo(40); // 第一次更新
        assertThat(finalRecord.getCalories()).isEqualTo(300); // 第二次更新
    }
}
```

**3. API兼容性回归测试**

```java
package org.dromara.sport.regression;

import org.dromara.common.core.domain.R;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * API兼容性回归测试
 * 目标：确保API向后兼容，不破坏旧版本客户端
 */
@SpringBootTest
@AutoConfigureMockMvc
@DisplayName("运动记录-API兼容性回归测试")
class ApiCompatibilityRegressionTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("API兼容: GET /sport/record/list 返回格式不变")
    void testApiCompatibility_ListFormat() throws Exception {
        mockMvc.perform(get("/sport/record/list"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.msg").exists())
            .andExpect(jsonPath("$.data").exists())
            .andExpect(jsonPath("$.data.rows").isArray())
            .andExpect(jsonPath("$.data.total").isNumber());
    }

    @Test
    @DisplayName("API兼容: 旧版分页参数仍然有效")
    void testApiCompatibility_LegacyPaginationParams() throws Exception {
        // 旧版使用 pageNum/pageSize
        mockMvc.perform(get("/sport/record/list")
                .param("pageNum", "1")
                .param("pageSize", "10"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.rows").isArray());

        // 新版使用 page/size（应同时支持）
        mockMvc.perform(get("/sport/record/list")
                .param("page", "1")
                .param("size", "10"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.rows").isArray());
    }

    @Test
    @DisplayName("API兼容: 新增字段不影响旧客户端")
    void testApiCompatibility_NewFieldsOptional() throws Exception {
        // 旧客户端只传必填字段（不传新增的可选字段）
        String oldClientRequest = """
            {
                "userId": 1,
                "sportType": "跑步",
                "duration": 30
            }
            """;

        mockMvc.perform(post("/sport/record")
                .contentType("application/json")
                .content(oldClientRequest))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200));
    }
}
```

**4. 性能基准回归测试**

```java
package org.dromara.sport.regression;

import org.dromara.sport.domain.SportRecord;
import org.dromara.sport.service.ISportRecordService;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.util.StopWatch;

import java.time.LocalDateTime;
import java.util.List;

import static org.assertj.core.api.Assertions.*;

/**
 * 性能基准回归测试
 * 目标：确保性能不劣化，响应时间在基线范围内
 */
@SpringBootTest
@DisplayName("运动记录-性能基准回归测试")
class PerformanceRegressionTest {

    @Autowired
    private ISportRecordService sportRecordService;

    private static final long BASELINE_CREATE_MS = 100;  // 创建操作基线: 100ms
    private static final long BASELINE_QUERY_MS = 50;    // 查询操作基线: 50ms
    private static final long BASELINE_UPDATE_MS = 80;   // 更新操作基线: 80ms
    private static final long BASELINE_DELETE_MS = 60;   // 删除操作基线: 60ms

    @Test
    @DisplayName("性能回归: 创建记录响应时间")
    void testPerformance_CreateRecord() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        // When: 创建记录
        SportRecord record = new SportRecord();
        record.setUserId(1L);
        record.setSportType("跑步");
        record.setDuration(30);
        record.setRecordTime(LocalDateTime.now());
        sportRecordService.save(record);

        stopWatch.stop();
        long elapsedMs = stopWatch.getTotalTimeMillis();

        // Then: 响应时间不超过基线
        assertThat(elapsedMs)
            .as("创建记录性能回归: 响应时间应小于%dms，实际%dms", BASELINE_CREATE_MS, elapsedMs)
            .isLessThanOrEqualTo(BASELINE_CREATE_MS);
    }

    @Test
    @DisplayName("性能回归: 批量查询响应时间")
    void testPerformance_BatchQuery() {
        // Given: 准备100条记录
        List<SportRecord> records = createTestRecords(100);
        sportRecordService.saveBatch(records);

        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        // When: 批量查询
        List<SportRecord> result = sportRecordService.list();

        stopWatch.stop();
        long elapsedMs = stopWatch.getTotalTimeMillis();

        // Then: 响应时间不超过基线
        assertThat(elapsedMs)
            .as("批量查询性能回归: 响应时间应小于%dms，实际%dms", BASELINE_QUERY_MS * 2, elapsedMs)
            .isLessThanOrEqualTo(BASELINE_QUERY_MS * 2);
    }

    private List<SportRecord> createTestRecords(int count) {
        return java.util.stream.IntStream.range(0, count)
            .mapToObj(i -> {
                SportRecord record = new SportRecord();
                record.setUserId(1L);
                record.setSportType("跑步");
                record.setDuration(30);
                record.setRecordTime(LocalDateTime.now());
                return record;
            })
            .toList();
    }
}
```

#### 回归测试基线文件示例

**baseline.json**
```json
{
  "version": "1.0.0",
  "createdAt": "2026-01-29T10:00:00Z",
  "testResults": {
    "CoreBusinessRegressionTest": {
      "totalTests": 5,
      "passed": 5,
      "failed": 0,
      "executionTimeMs": 2500
    },
    "HistoricalBugRegressionTest": {
      "totalTests": 4,
      "passed": 4,
      "failed": 0,
      "executionTimeMs": 1800
    },
    "ApiCompatibilityRegressionTest": {
      "totalTests": 3,
      "passed": 3,
      "failed": 0,
      "executionTimeMs": 1200
    },
    "PerformanceRegressionTest": {
      "totalTests": 2,
      "passed": 2,
      "failed": 0,
      "executionTimeMs": 800,
      "performanceBaseline": {
        "createMs": 85,
        "queryMs": 45,
        "updateMs": 70,
        "deleteMs": 55
      }
    }
  },
  "coverageReport": {
    "lineCoverage": 87,
    "branchCoverage": 82,
    "methodCoverage": 90
  }
}
```

#### 回归测试执行流程

```markdown
🔄 回归测试自动执行流程：

1️⃣ 首次运行（建立基线）
   ├─ 执行所有回归测试
   ├─ 保存测试结果到 baseline.json
   ├─ 保存性能数据到 performance.json
   └─ 输出：✅ 回归测试基线已建立

2️⃣ 后续运行（对比基线）
   ├─ 执行所有回归测试
   ├─ 对比当前结果与基线
   ├─ 检测新增失败用例
   ├─ 检测性能劣化（>10%）
   └─ 输出：
       ✅ 无回归问题 或
       ⚠️  检测到X个潜在回归问题

3️⃣ 基线更新（确认无问题后）
   ├─ 用户确认当前结果无问题
   ├─ 更新 baseline.json
   └─ 输出：✅ 回归测试基线已更新
```

#### 覆盖率目标分解

```
整体覆盖率目标: 85% 🆕

├─ 单元测试（Service层）: 90%+
│   ├─ CRUD方法: 100%
│   ├─ 业务逻辑方法: 85%+
│   └─ 异常处理: 80%+
│
├─ 接口测试（Controller层）: 85%+
│   ├─ RESTful接口: 95%+
│   ├─ 参数校验: 85%+
│   └─ 权限控制: 80%+
│
└─ 回归测试: 85%+ 🆕
    ├─ 核心业务流程: 100%
    ├─ 历史Bug场景: 100%
    ├─ API兼容性: 90%+
    └─ 性能基准: 80%+
```

---

## 步骤 9：代码质量检查

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 测试已通过（必须先完成步骤8）

**推荐检查项**:
- ⚠️ 测试覆盖率达标（建议测试覆盖率>80%）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 推荐项警告会询问是否继续
- 建议先确保测试覆盖率达到80%以上

**详细检查清单**: [dev-dependency-check.md - 步骤9](./dev-dependency-check.md#步骤9代码质量检查)

---

### 执行内容
- **执行方式**：在代码提交前进行全面质量检查
- **核心功能**：
	- **工具检测**：自动检测质量检查工具可用性（CheckStyle、PMD、SpotBugs、JaCoCo）
	- **静态分析**：执行静态代码分析（格式规范、潜在问题、Bug检测）
	- **安全扫描**：执行安全漏洞扫描（依赖漏洞、代码安全、权限控制）
	- **覆盖率分析**：分析测试覆盖率（整合步骤8的覆盖率报告）
	- **规范检查**：检查若依框架规范（继承关系、注解配置、命名规范）
	- **报告生成**：生成综合质量报告（问题分级、修复建议、风险评估）
	- **自动修复**：对于可自动修复的问题，提供一键修复方案
- **协作智能体**：
	- **输入来自**：`@test-engineer`（测试覆盖率报告）、`@code-reviewer`（代码审查问题）
	- **输出给**：`@project-manager`（质量报告）、`@bug-detective`（Critical问题）
	- **协作机制**：发现Critical问题时自动激活 `@bug-detective` 进行深度分析

---

### 🔍 前置检查：质量检查工具可用性验证

- **检测方式**：在执行质量检查前，先检查工具是否可用
- **检测步骤**：
	```bash
	# 1. 检查Maven插件配置
	grep -r "maven-checkstyle-plugin" pom.xml
	grep -r "jacoco-maven-plugin" pom.xml
	grep -r "maven-pmd-plugin" pom.xml
	grep -r "spotbugs-maven-plugin" pom.xml
	
	# 2. 检查是否可以执行Maven命令
	mvn --version
	```

- **检测结果处理**：
	- **情况A：工具已配置**（检测到插件配置）
		- ✅ 继续执行自动化质量检查
		- 执行命令：`mvn clean verify`
	
	- **情况B：工具部分配置**（仅部分插件存在）
		- ⚠️ 输出提示：
			```
			⚠️ 检测到部分质量检查工具未配置
			已配置: [列出已有的插件]
			未配置: [列出缺失的插件]
			
			建议：
			1. [推荐] 使用人工检查清单（见下方）
			2. [可选] 为项目配置缺失的Maven插件
			
			请选择 [1/2]:
			```
	
	- **情况C：工具未配置**（未检测到任何插件）
		- ⚠️ 自动切换到人工检查模式
		- 输出提示：
			```
			⚠️ 未检测到质量检查工具配置
			将使用人工检查清单进行质量验证
			
			💡 提示：如需自动化检查，可在后续配置Maven插件
			```

---

### 📋 人工检查清单（工具不可用时使用）

- **代码规范检查**（必选）
	- [ ] 所有 public 方法有 JavaDoc 注释
	- [ ] 类名使用大驼峰命名（PascalCase）
	- [ ] 方法名使用小驼峰命名（camelCase）
	- [ ] 常量使用全大写+下划线（UPPER_SNAKE_CASE）
	- [ ] 包名使用小写字母
	- [ ] 避免使用魔法数字（硬编码的数字）
	- [ ] 避免使用魔法字符串（硬编码的字符串）

- **代码质量检查**（必选）
	- [ ] 方法长度 < 50行（复杂方法需拆分）
	- [ ] 方法参数 < 5个（过多参数使用对象封装）
	- [ ] 类长度 < 500行（过大类需拆分）
	- [ ] 避免深层嵌套（if/for嵌套 < 3层）
	- [ ] 避免代码重复（相同逻辑抽取为方法）

- **安全检查**（必选）
	- [ ] 使用参数化查询（MyBatis的#{}，避免SQL注入）
	- [ ] 用户输入已进行校验（@Valid / @Validated）
	- [ ] 敏感信息已脱敏（日志中的密码、手机号等）
	- [ ] 文件上传已限制类型和大小
	- [ ] 异常信息不暴露敏感数据

- **性能检查**（可选）
	- [ ] 避免在循环中查询数据库
	- [ ] 大数据量查询使用分页
	- [ ] 正确关闭资源（流、连接等）
	- [ ] 避免创建不必要的对象

- **若依框架规范检查**（必选）
	- [ ] Entity 继承 BaseEntity
	- [ ] Mapper 继承 BaseMapperPlus
	- [ ] Service 继承 IService
	- [ ] Controller 添加 @SaCheckPermission 权限注解
	- [ ] 使用 LambdaQueryWrapper 构建查询条件
	- [ ] 使用 R.ok() / R.fail() 返回结果

---

### 🤖 自动化检查项目（工具可用时）

- **检查项目**（按优先级）：
	1. **静态代码分析**
		- 使用 CheckStyle 检查代码格式规范
		- 使用 PMD 检查潜在代码问题
		- 使用 SpotBugs 检查常见Bug模式
		- **验证标准**：
			- ✅ 无 Critical 级别问题
			- ✅ Major 级别问题 < 5个
	2. **安全漏洞扫描**
		- 使用 OWASP Dependency Check 扫描依赖漏洞
		- 检查 SQL 注入风险点（Mapper XML中的 ${} 使用）
		- 检查 XSS 攻击防护（Controller参数校验）
		- 检查权限控制（@SaCheckPermission注解）
		- **验证标准**：
			- ✅ 无高危漏洞（CVSS >= 7.0）
			- ✅ 中危漏洞已评估并记录
			- ✅ 所有Controller方法有权限注解
	3. **代码覆盖率整合分析**
		- **整合步骤8的覆盖率报告**（JaCoCo）
		- 检查核心业务逻辑覆盖率
		- 识别未覆盖的关键代码路径
		- **验证标准**：
			- ✅ 整体覆盖率 > 80%
			- ✅ Service 层覆盖率 > 90%
			- ✅ Controller 层覆盖率 > 85%
			- ✅ 关键业务方法覆盖率 = 100%
	4. **框架规范检查**
		- 检查 Entity 继承关系（必须继承 TenantEntity）
		- 检查 Mapper 继承关系（必须继承 BaseMapperPlus）
		- 检查 Service 依赖注入方式（使用构造器注入 + @RequiredArgsConstructor）
		- 检查 Controller 注解配置（@RestController + @SaCheckPermission + @Log）
		- 检查 JavaDoc 注释完整性
		- 检查命名规范（类/方法/变量）
		- **验证标准**：
			- ✅ 所有 Entity 正确继承 TenantEntity
			- ✅ 所有 Mapper 正确继承 BaseMapperPlus
			- ✅ 所有 public 方法有 JavaDoc
			- ✅ 符合若依框架命名规范
- **工具配置**（可选，提高效率）：
	```xml
	<!-- Maven pom.xml 中添加质量检查插件 -->
	<plugin>
	    <groupId>org.apache.maven.plugins</groupId>
	    <artifactId>maven-checkstyle-plugin</artifactId>
	    <version>3.3.0</version>
	</plugin>
	<plugin>
	    <groupId>org.jacoco</groupId>
	    <artifactId>jacoco-maven-plugin</artifactId>
	    <version>0.8.10</version>
	</plugin>
	<plugin>
	    <groupId>com.github.spotbugs</groupId>
	    <artifactId>spotbugs-maven-plugin</artifactId>
	    <version>4.7.3.5</version>
	</plugin>
	```
- **执行命令**（自动化）：
	```bash
	# 1. 运行所有检查
	mvn clean verify
	
	# 2. 生成质量报告
	mvn site
	
	# 3. 查看报告（自动打开浏览器）
	# target/site/checkstyle.html
	# target/site/jacoco/index.html
	# target/site/spotbugs.html
	```
- **问题处理**（自动化流程）：
	- 🔴 发现 Critical 问题：
		1. 立即暂停流程
		2. 激活 `@bug-detective` 深度分析
		3. 提供修复方案
		4. 修复后重新检查
	- 🟡 发现 Major 问题：
		1. 评估影响范围
		2. 提供修复建议
		3. 记录到 `docs/待办清单.md`
		4. 可选择立即修复或后续优化
	- 🟢 发现 Minor 问题：
		1. 记录到 `docs/待办清单.md`
		2. 标记为低优先级
		3. 不阻塞后续流程
- **输出示例**：
	```
	✅ 代码质量检查完成
	
	┌─────────────────────────────────────────┐
	│           质量检查结果                    │
	├─────────────────────────────────────────┤
	│ 静态分析   │ ✅ 通过 (0 Critical, 2 Major) │
	│ 安全扫描   │ ✅ 通过 (0 高危, 1 中危)      │
	│ 代码覆盖率 │ ✅ 85% (达标)                │
	│ 规范检查   │ ✅ 通过                      │
	└─────────────────────────────────────────┘
	
	⚠️ 需要关注的问题:
	
	【Major】
	- SportRecordServiceImpl.java:45
	  问题: 方法复杂度过高(15)
	  建议: 拆分为多个小方法
	  优先级: P2
	
	【中危漏洞】
	- commons-io:2.6
	  漏洞: CVE-2021-29425
	  风险评估: 不影响当前使用（仅使用文件读取功能）
	  建议: 后续升级到2.11.0
	  优先级: P3
	
	📊 覆盖率详情:
	- Service层: 92% ✅
	- Controller层: 88% ✅
	- Mapper层: 75% ⚠️ (低于90%目标)
	
	📝 已自动记录到待办清单:
	- [ ] [代码优化] 重构SportRecordServiceImpl.calcStatistics方法 - P2
	- [ ] [依赖升级] 升级commons-io到2.11.0 - P3
	- [ ] [测试补充] 提升Mapper层覆盖率到90% - P2
	```
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L2级别）：Critical问题自动修复并重新检查，最多3次
	- ⚠️ **需用户确认**（L3级别）：Major问题>10个时需用户选择回滚方案
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤9](./dev-rollback-guide.md#步骤9失败代码质量检查)

---

## 步骤 9.5：性能分析与优化 🆕

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 代码质量检查已通过（必须先完成步骤9）
- 🚫 测试已通过（必须先完成步骤8）

**推荐检查项**:
- ⚠️ 数据库表已创建（建议先完成步骤5）
- ⚠️ 后端代码已完成（建议先完成步骤6）

**检查失败处理**:
- 必需项检查失败会暂停执行
- 推荐项警告会询问是否继续

**详细检查清单**: [dev-dependency-check.md - 步骤9.5](./dev-dependency-check.md#步骤95性能分析)

---

### ⚡ 默认执行策略：快速扫描（2分钟）⭐⭐⭐⭐⭐

**核心理念**：**默认自动执行快速扫描**，提高执行率至90%+，避免遗漏关键性能问题

#### 执行模式

**🟢 快速扫描模式（默认自动执行）** ⭐：
- ✅ **执行时长**：2分钟
- ✅ **检测范围**：关键性能问题（SQL缺失索引、N+1查询、大对象处理）
- ✅ **输出方式**：直接输出优化建议清单（不生成报告文件）
- ✅ **Token消耗**：极低（<200 tokens，节省85%）
- ✅ **执行率**：90%+（自动执行，无需确认）

**🔵 完整分析模式（可选）**：
- ⏱️ **执行时长**：15-20分钟
- 📊 **检测范围**：全面深度分析
- 📄 **输出方式**：生成详细性能报告
- 💰 **Token消耗**：中等（5,000-8,000 tokens）
- 🎯 **适用场景**：核心业务模块、正式发布前

#### 默认执行流程

```markdown
⚡ 步骤9.5：性能分析（自动执行）

🔄 正在执行快速扫描...（预计2分钟）

[SQL检查] ━━━━━━━━━━━━━━━━━━━━ 100% (45秒)
✅ 发现2个优化点
  - 缺失索引: sport_record.create_time
  - N+1查询: SportRecordServiceImpl.getRecordList()

[后端检查] ━━━━━━━━━━━━━━━━━━━━ 100% (45秒)
✅ 发现1个优化点
  - 循环查询: 建议使用批量查询

[前端检查] ━━━━━━━━━━━━━━━━━━━━ 100% (30秒)
✅ 发现1个优化点
  - 大列表渲染: 建议使用虚拟滚动

✅ 快速扫描完成！

📋 优化建议清单（按优先级）:

【P0 - 高优先级】
1. [SQL] 添加索引 idx_create_time
   影响: 查询时间 2000ms → 20ms (↓99%)
   ```sql
   ALTER TABLE sport_record ADD INDEX idx_create_time (create_time);
   ```

2. [后端] 修复N+1查询问题
   影响: 100条记录执行时间 800ms → 80ms (↓90%)
   位置: SportRecordServiceImpl.getRecordList()

【P1 - 中优先级】
3. [后端] 使用批量查询替代循环查询
   影响: 响应时间↓70%

4. [前端] 大列表使用虚拟滚动
   影响: 首次渲染↓90%

⏭️  继续执行步骤10...

💡 提示: 如需完整性能分析，可后续手动执行
```

#### 何时使用完整分析

**建议使用完整分析的场景**：
- 🎯 核心业务模块（订单、支付、用户认证）
- 🚀 正式发布前的全面检查
- 📊 需要性能基准测试和对比
- 🔍 快速扫描发现Critical问题需深入分析

---

### 执行内容

- **执行方式**：**默认自动执行快速扫描**（2分钟）
- **核心功能**：
	- **默认执行模式**：快速扫描（2分钟）⭐⭐⭐⭐⭐
	- **自动化执行**：无需用户确认，自动执行快速扫描
	- **快速检测**：7大类关键性能问题
	  - SQL性能（索引缺失、SELECT *、全表扫描）
	  - N+1查询（循环内数据库查询）
	  - 内存泄漏（静态集合、ThreadLocal、监听器）🆕
	  - 并发瓶颈（锁竞争、线程池、死锁风险）🆕
	  - 大对象处理（List<Object>全量加载）
	  - 缓存优化（未使用缓存、缓存过期策略）
	  - 前端性能（虚拟滚动、防抖节流、打包体积）
	- **直接输出**：优化建议清单（不生成报告文件）
	- **极低Token**：<200 tokens（节省85%）
	- **可选完整分析**：15-20分钟深度分析（仅在必要时）

---

### 1. SQL性能分析与优化

#### 分析内容

**慢查询检测**：
- 分析所有Mapper XML中的SQL语句
- 识别潜在的慢查询（N+1问题、全表扫描、缺失索引）
- 评估查询复杂度和执行计划

**索引优化**：
- 检查是否缺少必要的索引
- 识别冗余索引和未使用的索引
- 分析联合索引的列顺序是否合理
- 评估索引覆盖率

**查询优化**：
- 检查是否存在SELECT *（建议明确列名）
- 识别不必要的JOIN操作
- 检查是否使用了合适的分页策略
- 分析子查询是否可以优化为JOIN

**数据库设计**：
- 检查表结构是否符合范式要求
- 识别可能的数据冗余
- 评估字段类型选择是否合理
- 检查是否需要分区表

#### 优化示例

```xml
<!-- ❌ 优化前：存在N+1问题 -->
<select id="selectRecordList" resultMap="SportRecordResult">
    select * from sport_record where del_flag = '0'
</select>
<!-- 在Service中循环查询用户信息 -->

<!-- ✅ 优化后：使用JOIN一次查询 -->
<select id="selectRecordList" resultMap="SportRecordResult">
    select 
        r.record_id, r.user_id, r.sport_type, r.duration,
        u.user_name, u.nick_name
    from sport_record r
    left join sys_user u on r.user_id = u.user_id
    where r.del_flag = '0'
</select>
```

```xml
<!-- ❌ 优化前：缺少索引，全表扫描 -->
<select id="selectByDateRange">
    select * from sport_record 
    where create_time between #{startTime} and #{endTime}
</select>

<!-- ✅ 优化后：添加索引 + 明确列名 -->
<!-- 建议添加索引：idx_create_time -->
<select id="selectByDateRange">
    select record_id, user_id, sport_type, duration, create_time
    from sport_record 
    where create_time between #{startTime} and #{endTime}
    and del_flag = '0'
</select>
```

#### 输出产物

```markdown
## 📊 SQL性能分析报告

### 慢查询风险
1. ⚠️ SportRecordMapper.selectRecordList
   - 问题: 存在N+1查询问题
   - 影响: 100条记录需执行101次查询
   - 优化建议: 使用LEFT JOIN关联用户表
   - 预期提升: 查询时间从500ms降至50ms (↓90%)

2. ⚠️ SportRecordMapper.selectByDateRange
   - 问题: create_time字段缺少索引
   - 影响: 全表扫描，10万条数据需2秒
   - 优化建议: 添加索引 idx_create_time
   - 预期提升: 查询时间从2000ms降至20ms (↓99%)

### 索引建议
```sql
-- 添加单列索引
ALTER TABLE sport_record ADD INDEX idx_create_time (create_time);
ALTER TABLE sport_record ADD INDEX idx_user_id (user_id);

-- 添加联合索引（用于复合查询）
ALTER TABLE sport_record ADD INDEX idx_user_date (user_id, create_time);
```

### 查询优化建议
- ✅ 已优化: 3个查询
- ⚠️ 待优化: 2个查询
- 📈 预期性能提升: 平均响应时间 ↓85%
```

---

### 2. 后端代码性能分析

#### 分析内容

**代码热点分析**：
- 识别高频调用的方法
- 分析方法执行时间
- 检测CPU密集型操作
- 识别内存占用过高的代码

**算法复杂度**：
- 分析循环嵌套深度
- 识别O(n²)及以上的算法
- 检查是否存在不必要的重复计算
- 评估集合操作的效率

**缓存优化**：
- 检查是否使用了合适的缓存策略
- 识别可以缓存的数据
- 分析缓存命中率
- 检查缓存过期策略

**并发优化**：
- 检查是否可以使用异步处理
- 识别可以并行执行的任务
- 分析线程池配置是否合理
- 检查是否存在锁竞争

**资源管理**：
- 检查数据库连接是否正确关闭
- 识别内存泄漏风险（静态集合、ThreadLocal、监听器未注销）
- 分析文件句柄使用
- 检查线程资源释放

**内存泄漏检测** 🆕：
- 检测静态集合未清理（HashMap、List、Set持续增长）
- ThreadLocal对象未remove（Web应用中的隐患）
- 监听器/回调未注销（EventListener、Callback未移除）
- 大对象缓存未设置过期时间
- 数据库ResultSet、Connection未关闭
- 文件流、网络连接未正确关闭
- 内部类持有外部类引用导致的泄漏

**并发瓶颈检测** 🆕：
- synchronized同步块覆盖范围过大
- 高并发下的锁竞争（Lock、ReentrantLock使用不当）
- 单例模式的线程安全问题
- 共享变量的并发访问（未使用volatile或原子类）
- 线程池配置不合理（核心线程数、最大线程数、队列大小）
- 数据库连接池耗尽风险（HikariCP配置检查）
- 并发集合使用不当（ConcurrentHashMap vs HashMap）
- 死锁风险检测（多个锁的获取顺序）

#### 优化示例

```java
// ❌ 优化前：循环中查询数据库（N+1问题）
public List<SportRecordVo> getRecordList() {
    List<SportRecord> records = recordMapper.selectList();
    List<SportRecordVo> voList = new ArrayList<>();
    for (SportRecord record : records) {
        SportRecordVo vo = new SportRecordVo();
        BeanUtils.copyProperties(record, vo);
        // 每次循环都查询数据库
        SysUser user = userMapper.selectById(record.getUserId());
        vo.setUserName(user.getUserName());
        voList.add(vo);
    }
    return voList;
}

// ✅ 优化后：批量查询 + Map缓存
public List<SportRecordVo> getRecordList() {
    List<SportRecord> records = recordMapper.selectList();
    
    // 批量查询用户信息
    Set<Long> userIds = records.stream()
        .map(SportRecord::getUserId)
        .collect(Collectors.toSet());
    Map<Long, SysUser> userMap = userMapper.selectByIds(userIds).stream()
        .collect(Collectors.toMap(SysUser::getUserId, Function.identity()));
    
    // 组装VO
    return records.stream().map(record -> {
        SportRecordVo vo = new SportRecordVo();
        BeanUtils.copyProperties(record, vo);
        SysUser user = userMap.get(record.getUserId());
        if (user != null) {
            vo.setUserName(user.getUserName());
        }
        return vo;
    }).collect(Collectors.toList());
}
```

```java
// ❌ 优化前：重复计算
public BigDecimal calculateTotalCalories(Long userId, LocalDate date) {
    List<SportRecord> records = recordMapper.selectByUserAndDate(userId, date);
    BigDecimal total = BigDecimal.ZERO;
    for (SportRecord record : records) {
        // 每次循环都计算，即使sport_type相同
        BigDecimal caloriesPerMinute = getCaloriesPerMinute(record.getSportType());
        total = total.add(caloriesPerMinute.multiply(new BigDecimal(record.getDuration())));
    }
    return total;
}

// ✅ 优化后：缓存计算结果
@Cacheable(value = "caloriesRate", key = "#sportType")
public BigDecimal getCaloriesPerMinute(String sportType) {
    // 从配置表查询或使用预定义值
    return caloriesRateMap.get(sportType);
}

public BigDecimal calculateTotalCalories(Long userId, LocalDate date) {
    List<SportRecord> records = recordMapper.selectByUserAndDate(userId, date);
    return records.stream()
        .map(record -> getCaloriesPerMinute(record.getSportType())
            .multiply(new BigDecimal(record.getDuration())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
}
```

#### 输出产物

```markdown
## 🔧 后端性能分析报告

### 性能热点
1. ⚠️ SportRecordServiceImpl.getRecordList()
   - 问题: N+1查询问题
   - 影响: 100条记录执行101次数据库查询
   - 优化建议: 使用批量查询 + Map缓存
   - 预期提升: 响应时间从800ms降至80ms (↓90%)

2. ⚠️ SportRecordServiceImpl.calculateTotalCalories()
   - 问题: 重复计算卡路里消耗率
   - 影响: 相同运动类型重复查询配置
   - 优化建议: 使用@Cacheable缓存
   - 预期提升: 响应时间从200ms降至20ms (↓90%)

### 算法复杂度
- ✅ 无O(n²)及以上复杂度算法
- ✅ 集合操作使用Stream API优化

### 缓存建议
```java
// 建议添加缓存
@Cacheable(value = "sportRecord", key = "#id")
public SportRecordVo selectById(Long id) { ... }

@Cacheable(value = "caloriesRate", key = "#sportType")
public BigDecimal getCaloriesPerMinute(String sportType) { ... }
```

### 内存泄漏检测 🆕
1. ⚠️ CacheManager.CACHE (静态集合)
   - 问题: 静态HashMap无限增长，未设置上限和过期策略
   - 影响: 长时间运行后可能导致OOM（OutOfMemoryError）
   - 优化建议: 使用Caffeine缓存，设置maximumSize=1000，expireAfterWrite=1小时
   - 预期提升: 避免内存泄漏，堆内存使用稳定在合理范围

2. ⚠️ UserContext.USER_HOLDER (ThreadLocal)
   - 问题: ThreadLocal对象使用后未调用remove()
   - 影响: 线程池复用时可能导致内存泄漏和数据混乱
   - 优化建议: 在Filter/Interceptor的finally块中调用UserContext.clear()
   - 预期提升: 避免内存泄漏，防止用户信息串用

3. ⚠️ EventService.listeners (监听器集合)
   - 问题: 添加监听器后无法移除，持续累积
   - 影响: 监听器对象无法被GC回收
   - 优化建议: 提供removeEventListener方法，使用CopyOnWriteArrayList
   - 预期提升: 及时释放不用的监听器，避免内存泄漏

### 并发瓶颈检测 🆕
1. ⚠️ SportRecordService.getAllRecords() (锁粒度过大)
   - 问题: 整个方法使用synchronized，高并发下性能差
   - 影响: 100个并发请求需串行执行，响应时间×100
   - 优化建议: 使用双重检查锁定（DCL）+ volatile，缩小同步范围
   - 预期提升: 并发吞吐量提升50倍（100 TPS → 5000 TPS）

2. ⚠️ ThreadPoolConfig.taskExecutor (线程池配置不当)
   - 问题: corePoolSize=1, maxPoolSize=2, queueCapacity=10 太小
   - 影响: 高并发下频繁拒绝任务，性能瓶颈明显
   - 优化建议: 设置corePoolSize=CPU核心数×2，maxPoolSize=CPU核心数×4，queueCapacity=500
   - 预期提升: 并发处理能力提升20倍

3. ⚠️ CounterService.counter (非线程安全变量)
   - 问题: 共享变量int counter使用++操作，非原子性
   - 影响: 高并发下计数不准确，可能少计数30%
   - 优化建议: 使用AtomicInteger替代int
   - 预期提升: 计数100%准确，性能开销<5%

4. ⚠️ CacheService.cache (非线程安全集合)
   - 问题: HashMap在多线程环境使用，高并发下可能死循环
   - 影响: CPU 100%占用，服务hang住
   - 优化建议: 使用ConcurrentHashMap替代HashMap
   - 预期提升: 线程安全，避免死循环风险

5. ⚠️ DeadlockRisk (死锁风险)
   - 问题: method1和method2锁获取顺序不一致（lock1→lock2 vs lock2→lock1）
   - 影响: 高并发下可能发生死锁，服务不可用
   - 优化建议: 统一锁获取顺序为lock1→lock2
   - 预期提升: 消除死锁风险，系统稳定性提升

### 并发优化
- 💡 建议: 统计分析可使用@Async异步处理
- 💡 建议: 批量导入可使用CompletableFuture并行处理

### 内存泄漏检测 🆕
```java
// ⚠️ 内存泄漏风险1: 静态集合未清理
public class CacheManager {
    private static final Map<String, Object> CACHE = new HashMap<>(); // 风险
    
    public void addCache(String key, Object value) {
        CACHE.put(key, value); // 持续增长，永不清理
    }
}

// ✅ 优化: 使用带过期时间的缓存
@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(1, TimeUnit.HOURS));
        return cacheManager;
    }
}

// ⚠️ 内存泄漏风险2: ThreadLocal未清理
public class UserContext {
    private static final ThreadLocal<UserInfo> USER_HOLDER = new ThreadLocal<>();
    
    public static void setUser(UserInfo user) {
        USER_HOLDER.set(user); // 线程池复用时未清理
    }
}

// ✅ 优化: 使用后立即清理
public class UserContext {
    private static final ThreadLocal<UserInfo> USER_HOLDER = new ThreadLocal<>();
    
    public static void setUser(UserInfo user) {
        USER_HOLDER.set(user);
    }
    
    public static void clear() {
        USER_HOLDER.remove(); // 必须调用
    }
}

// 在Filter或Interceptor中确保清理
@Component
public class UserContextFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
        try {
            chain.doFilter(request, response);
        } finally {
            UserContext.clear(); // 确保清理
        }
    }
}

// ⚠️ 内存泄漏风险3: 监听器未注销
@Service
public class EventService {
    private final List<EventListener> listeners = new ArrayList<>();
    
    public void addEventListener(EventListener listener) {
        listeners.add(listener); // 监听器累积
    }
}

// ✅ 优化: 提供注销方法
@Service
public class EventService {
    private final List<EventListener> listeners = new CopyOnWriteArrayList<>();
    
    public void addEventListener(EventListener listener) {
        listeners.add(listener);
    }
    
    public void removeEventListener(EventListener listener) {
        listeners.remove(listener); // 及时移除
    }
}
```

### 并发瓶颈检测 🆕
```java
// ⚠️ 并发瓶颈1: synchronized范围过大
@Service
public class SportRecordService {
    public synchronized List<SportRecord> getAllRecords() { // 整个方法同步
        return recordMapper.selectList();
    }
}

// ✅ 优化: 缩小同步范围
@Service
public class SportRecordService {
    private final Object lock = new Object();
    private volatile List<SportRecord> cachedRecords;
    
    public List<SportRecord> getAllRecords() {
        if (cachedRecords == null) {
            synchronized (lock) { // 仅同步必要代码块
                if (cachedRecords == null) {
                    cachedRecords = recordMapper.selectList();
                }
            }
        }
        return cachedRecords;
    }
}

// ⚠️ 并发瓶颈2: 线程池配置不合理
@Configuration
public class ThreadPoolConfig {
    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(1); // 太小，高并发下性能差
        executor.setMaxPoolSize(2);
        executor.setQueueCapacity(10); // 队列太小，易拒绝任务
        return executor;
    }
}

// ✅ 优化: 根据业务场景合理配置
@Configuration
public class ThreadPoolConfig {
    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        int cpuCores = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(cpuCores * 2); // CPU密集型: cpuCores+1, IO密集型: cpuCores*2
        executor.setMaxPoolSize(cpuCores * 4);
        executor.setQueueCapacity(500); // 根据业务峰值设置
        executor.setThreadNamePrefix("async-task-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        return executor;
    }
}

// ⚠️ 并发瓶颈3: 共享变量无并发控制
@Service
public class CounterService {
    private int counter = 0; // 多线程不安全
    
    public void increment() {
        counter++; // 非原子操作
    }
}

// ✅ 优化: 使用原子类
@Service
public class CounterService {
    private final AtomicInteger counter = new AtomicInteger(0);
    
    public void increment() {
        counter.incrementAndGet(); // 原子操作
    }
}

// ⚠️ 并发瓶颈4: 集合并发使用不当
@Service
public class CacheService {
    private final Map<String, Object> cache = new HashMap<>(); // 非线程安全
    
    public void put(String key, Object value) {
        cache.put(key, value); // 高并发下可能导致死循环
    }
}

// ✅ 优化: 使用并发集合
@Service
public class CacheService {
    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    
    public void put(String key, Object value) {
        cache.put(key, value); // 线程安全
    }
}

// ⚠️ 并发瓶颈5: 死锁风险
public class DeadlockRisk {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) { // 锁顺序: lock1 -> lock2
                // business logic
            }
        }
    }
    
    public void method2() {
        synchronized (lock2) {
            synchronized (lock1) { // 锁顺序: lock2 -> lock1，死锁风险！
                // business logic
            }
        }
    }
}

// ✅ 优化: 统一锁获取顺序
public class DeadlockFixed {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();
    
    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) { // 统一顺序: lock1 -> lock2
                // business logic
            }
        }
    }
    
    public void method2() {
        synchronized (lock1) {
            synchronized (lock2) { // 统一顺序: lock1 -> lock2
                // business logic
            }
        }
    }
}
```

---

### 3. 前端性能分析与优化

#### 分析内容

**渲染性能**：
- 检查是否存在不必要的重渲染
- 分析组件渲染次数
- 识别大列表渲染性能问题
- 检查是否使用了虚拟滚动

**网络请求优化**：
- 检查是否存在重复请求
- 分析请求合并机会
- 识别可以预加载的资源
- 检查是否使用了请求缓存

**资源加载优化**：
- 分析打包体积
- 检查是否使用了代码分割
- 识别未使用的依赖
- 检查图片资源优化

**交互性能**：
- 检查防抖节流使用
- 分析事件监听器数量
- 识别内存泄漏风险
- 检查动画性能

#### 优化示例

```vue
<!-- ❌ 优化前：每次输入都触发搜索 -->
<template>
  <el-input v-model="searchText" @input="handleSearch" />
</template>

<script>
export default {
  methods: {
    handleSearch() {
      // 每次输入都发送请求
      this.loadData();
    }
  }
}
</script>

<!-- ✅ 优化后：使用防抖 -->
<template>
  <el-input v-model="searchText" @input="debouncedSearch" />
</template>

<script>
import { debounce } from 'lodash-es';

export default {
  created() {
    // 300ms防抖
    this.debouncedSearch = debounce(this.handleSearch, 300);
  },
  methods: {
    handleSearch() {
      this.loadData();
    }
  }
}
</script>
```

```vue
<!-- ❌ 优化前：大列表直接渲染 -->
<template>
  <div>
    <div v-for="item in list" :key="item.id">
      {{ item.name }}
    </div>
  </div>
</template>

<!-- ✅ 优化后：使用虚拟滚动 -->
<template>
  <el-virtual-list
    :data="list"
    :item-height="50"
    :height="600"
  >
    <template #default="{ item }">
      <div>{{ item.name }}</div>
    </template>
  </el-virtual-list>
</template>
```

```javascript
// ❌ 优化前：重复请求
async mounted() {
  await this.loadUserInfo();
  await this.loadRecordList();
  await this.loadStatistics();
}

// ✅ 优化后：并行请求
async mounted() {
  await Promise.all([
    this.loadUserInfo(),
    this.loadRecordList(),
    this.loadStatistics()
  ]);
}
```

#### 输出产物

```markdown
## 🎨 前端性能分析报告

### 渲染性能
1. ⚠️ SportRecordList.vue
   - 问题: 大列表直接渲染1000+条数据
   - 影响: 首次渲染耗时3秒，滚动卡顿
   - 优化建议: 使用虚拟滚动或分页
   - 预期提升: 首次渲染 ↓90%，滚动流畅

2. ✅ SportRecordForm.vue
   - 状态: 使用v-show优化，性能良好

### 网络请求
1. ⚠️ SportRecordIndex.vue
   - 问题: 串行加载3个接口，总耗时900ms
   - 优化建议: 使用Promise.all并行加载
   - 预期提升: 加载时间从900ms降至300ms (↓67%)

2. ⚠️ 搜索输入框
   - 问题: 每次输入都触发搜索请求
   - 优化建议: 添加300ms防抖
   - 预期提升: 减少80%无效请求

### 资源加载
- 📦 打包体积: 2.5MB (建议<2MB)
- 💡 优化建议: 
  - 使用代码分割（路由懒加载）
  - 移除未使用的Element Plus组件
  - 图片使用WebP格式
- 📈 预期提升: 打包体积 ↓30%

### 交互性能
- ✅ 已使用防抖: 搜索框
- ✅ 已使用节流: 滚动加载
- ⚠️ 建议添加: 窗口resize事件节流
```

---

### 4. 性能测试与基准对比

#### 测试内容

**接口性能测试**：
```bash
# 使用JMeter或ab进行压力测试
ab -n 1000 -c 10 http://localhost:8080/sport/record/list

# 测试结果示例
Requests per second: 250 [#/sec]
Time per request: 40 [ms] (mean)
```

**数据库性能测试**：
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 0.1;

-- 分析慢查询
EXPLAIN SELECT * FROM sport_record WHERE create_time > '2024-01-01';
```

**前端性能测试**：
```javascript
// 使用Lighthouse进行性能评分
// Performance: 85/100
// First Contentful Paint: 1.2s
// Largest Contentful Paint: 2.5s
```

#### 输出产物

```markdown
## 📈 性能测试报告

### 接口性能基准
| 接口 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| GET /record/list | 800ms | 80ms | ↓90% |
| POST /record/add | 150ms | 120ms | ↓20% |
| GET /record/statistics | 2000ms | 200ms | ↓90% |

### 数据库性能基准
| 查询 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 日期范围查询 | 2000ms | 20ms | ↓99% |
| 用户记录查询 | 500ms | 50ms | ↓90% |
| 统计分析查询 | 3000ms | 300ms | ↓90% |

### 前端性能基准
| 指标 | 优化前 | 优化后 | 目标 |
|------|--------|--------|------|
| Lighthouse评分 | 65 | 85 | >80 |
| 首次内容绘制 | 2.5s | 1.2s | <1.5s |
| 最大内容绘制 | 4.5s | 2.5s | <2.5s |
| 打包体积 | 2.5MB | 1.8MB | <2MB |

### 综合评估
- ✅ 接口平均响应时间提升: 85%
- ✅ 数据库查询性能提升: 90%
- ✅ 前端加载速度提升: 50%
- ✅ 用户体验评分: 从C级提升到A级
```

---

### 5. 性能优化清单

#### 自动生成待办清单

```markdown
## 🎯 性能优化待办清单

### 高优先级（P0）- 严重影响性能和稳定性
- [ ] [SQL优化] 添加索引 idx_create_time - 预期提升99%
- [ ] [后端优化] 修复N+1查询问题 - 预期提升90%
- [ ] [内存泄漏] 修复CacheManager静态集合无限增长 - 避免OOM 🆕
- [ ] [并发瓶颈] 修复死锁风险（统一锁顺序）- 避免服务不可用 🆕
- [ ] [并发瓶颈] HashMap改为ConcurrentHashMap - 避免死循环 🆕
- [ ] [前端优化] 大列表使用虚拟滚动 - 预期提升90%

### 中优先级（P1）- 明显影响性能
- [ ] [SQL优化] 优化统计查询SQL - 预期提升85%
- [ ] [后端优化] 添加缓存@Cacheable - 预期提升80%
- [ ] [内存泄漏] ThreadLocal添加清理逻辑（Filter中调用remove）🆕
- [ ] [并发瓶颈] 缩小synchronized范围（DCL+volatile）- 提升50倍吞吐量 🆕
- [ ] [并发瓶颈] 优化线程池配置（corePoolSize=CPU×2）- 提升20倍处理能力 🆕
- [ ] [前端优化] 接口并行加载 - 预期提升67%

### 低优先级（P2）- 优化改进
- [ ] [内存泄漏] 监听器提供注销方法 🆕
- [ ] [并发瓶颈] int counter改为AtomicInteger - 确保计数准确 🆕
- [ ] [前端优化] 代码分割减小打包体积 - 预期提升30%
- [ ] [前端优化] 图片使用WebP格式 - 预期提升20%
- [ ] [后端优化] 统计分析异步处理 - 提升用户体验

### 检测项统计 🆕
- ✅ SQL性能: 2项
- ✅ N+1查询: 1项
- ✅ 内存泄漏: 3项 🆕
- ✅ 并发瓶颈: 5项 🆕
- ✅ 前端优化: 3项
- 📊 总计: 14项优化建议
```

---

### 执行流程

```markdown
步骤9.5执行流程（自动化）：

⚡ 快速扫描模式（默认自动执行）⭐⭐⭐⭐⭐

1️⃣ SQL关键问题检查（45秒）
   ├─ 自动扫描所有Mapper XML
   ├─ 检测关键问题：
   │   - SELECT * 语句
   │   - 缺失索引字段
   │   - N+1查询模式
   │   - 全表扫描风险
   └─ 直接输出优化建议（优先级排序）

2️⃣ 后端热点检查（30秒）
   ├─ 自动扫描Service层代码
   ├─ 检测关键问题：
   │   - 循环内数据库查询
   │   - 大对象处理
   │   - 重复计算
   │   - 未使用缓存
   └─ 直接输出优化建议（优先级排序）

3️⃣ 内存泄漏检测（20秒）🆕
   ├─ 自动扫描代码中的资源管理
   ├─ 检测关键问题：
   │   - 静态集合无限增长（HashMap/List/Set）
   │   - ThreadLocal未remove
   │   - 监听器/回调未注销
   │   - 缓存未设置过期时间
   │   - 数据库连接/文件流未关闭
   │   - 内部类持有外部类引用
   └─ 直接输出优化建议（优先级排序）

4️⃣ 并发瓶颈检测（20秒）🆕
   ├─ 自动扫描并发相关代码
   ├─ 检测关键问题：
   │   - synchronized范围过大
   │   - 锁竞争（Lock使用不当）
   │   - 共享变量无并发控制（未用volatile/原子类）
   │   - 线程池配置不合理
   │   - 非线程安全集合（HashMap vs ConcurrentHashMap）
   │   - 死锁风险（锁获取顺序）
   │   - 数据库连接池配置不当
   └─ 直接输出优化建议（优先级排序）

5️⃣ 前端快速检查（20秒）
   ├─ 自动扫描Vue组件
   ├─ 检测关键问题：
   │   - 大列表未虚拟化
   │   - 重复网络请求
   │   - 未使用防抖节流
   │   - 打包体积过大
   └─ 直接输出优化建议（优先级排序）

6️⃣ 输出结果（直接显示）
   ├─ 按优先级输出建议清单（P0/P1/P2）
   ├─ 生成索引DDL脚本（如需要）
   ├─ 输出内存泄漏修复建议 🆕
   ├─ 输出并发瓶颈优化建议 🆕
   └─ 不生成详细报告文档

总耗时: 2分钟（自动执行，无等待）⭐
检测项: 7大类（SQL/N+1/索引/内存泄漏/并发瓶颈/大对象/缓存）🆕

--- 可选：完整分析模式（15-20分钟）---

如需深度分析，可手动触发：
- 完整SQL执行计划分析
- 性能基准测试
- 详细性能报告生成

触发条件：
- 核心业务模块
- 正式发布前检查
- 快速扫描发现Critical问题
```

---

### 输出产物

**快速扫描模式（默认自动执行）** ⭐⭐⭐⭐⭐：

1. **优化建议清单**（直接输出到控制台，不生成文件）
   ```
   📋 性能优化建议

   【P0 - 高优先级】
   1. [SQL] 添加索引 idx_create_time
      影响: 查询时间↓99%
      ```sql
      ALTER TABLE sport_record ADD INDEX idx_create_time (create_time);
      ```

   2. [后端] 修复N+1查询问题
      影响: 响应时间↓90%
      位置: SportRecordServiceImpl.getRecordList()

   【P1 - 中优先级】
   3. [后端] 使用批量查询
      影响: 响应时间↓70%

   4. [前端] 使用虚拟滚动
      影响: 渲染时间↓90%

   【P2 - 低优先级】
   5. [前端] 代码分割
      影响: 打包体积↓30%
   ```

2. **索引DDL脚本**（仅在发现缺失索引时生成）
   - 保存位置: `sql/performance/indexes_[日期].sql`
   - 包含必需的索引创建语句

3. **不生成以下文件**：
   - ❌ 性能分析报告.md
   - ❌ 性能测试报告.md
   - ❌ 待办清单更新（手动记录即可）

**完整分析模式（手动触发）**：

1. **性能分析报告**（保存到 `docs/性能分析报告.md`）
2. **优化待办清单**（追加到 `docs/待办清单.md`）
3. **索引创建脚本**（保存到 `sql/performance/`）

---

### 注意事项

1. **默认自动执行** ⭐⭐⭐⭐⭐
   - ✅ **无需确认**：自动执行快速扫描，无需等待用户确认
   - ✅ **执行率90%+**：默认执行，避免遗漏关键性能问题
   - ✅ **2分钟完成**：快速检测明显问题，不影响开发节奏
   - ✅ **不生成报告**：直接输出优化建议清单，节省Token

2. **性能分析不修改代码**
   - 步骤9.5仅分析和输出建议
   - 不自动修改代码（避免引入风险）
   - 优化建议供后续实施参考

3. **两种执行模式**
   - **快速扫描（默认自动执行）**: 2分钟，不生成报告 ⭐⭐⭐⭐⭐
   - **完整分析（手动触发）**: 15-20分钟，生成详细报告

4. **Token消耗对比**
   - 快速扫描: <200 tokens（节省85%）⭐
   - 完整分析: 5,000-8,000 tokens

---

### Token消耗

| 模式 | Token消耗 | 耗时 | 输出 | 推荐度 |
|------|----------|------|------|--------|
| **快速扫描（默认）** | <200 | 2分钟 | 优化建议清单 | ⭐⭐⭐⭐⭐ |
| 完整分析（可选） | 5,000-8,000 | 15-20分钟 | 详细报告 | ⭐⭐⭐ |

**优化效果**：
- 节省Token: 85% (从5,000降至<200)
- 执行率提升: 90%+ (自动执行，无需确认)
- 开发效率: 不影响开发节奏（仅2分钟）

---

### 智能体协作

- **主智能体**: `@performance-analyzer`
- **协作智能体**:
  - `@database-ops` - SQL分析
  - `@code-reviewer` - 代码扫描
  - `@test-engineer` - 性能测试

---

- **⚠️ 失败处理**：
	- 🤖 **自动跳过**（L0级别）：分析工具不可用时自动跳过，不影响主流程
	- 🤖 **静默执行**（L0级别）：默认自动执行快速扫描，无需人工干预
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤9.5](./dev-rollback-guide.md#步骤95失败性能分析)
- **💾 检查点** 🆕：
	- ✅ **自动保存**：步骤完成后自动创建检查点 `cp_step9.5_completed`
	- ✅ **保存内容**：优化建议清单、索引DDL脚本（如有）
	- ✅ **不保存**：不生成性能分析报告文档
	- ✅ **恢复能力**：后续步骤失败时可查看优化建议

---

## 步骤 10：文档更新

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 质量检查已通过（必须先完成步骤9）
- 🚫 项目文档目录存在（必须先完成步骤4）

**推荐检查项**: 无

**检查失败处理**:
- 必需项检查失败会暂停执行
- 系统会提示需要完成的前置步骤

**详细检查清单**: [dev-dependency-check.md - 步骤10](./dev-dependency-check.md#步骤10文档更新)

---

### 执行内容与同步
- **执行方式**：自动更新项目文档并生成进度报告
- **核心功能**：
	- **状态同步**：维护项目状态文档（`docs/项目状态.md`）
	- **待办管理**：更新待办清单（`docs/待办清单.md`）
	- **进度统计**：统计开发进度并生成报告
	- **自动分析**：基于Git日志自动提取完成的功能和代码变更
	- **质量整合**：整合步骤8、步骤9的质量指标和问题清单
	- **风险识别**：识别潜在风险并提供应对措施
- **执行指令**（智能选择）：
	1. **必选**：`commands/update-status.md` - 更新项目整体状态
	2. **智能判断**：`commands/update-todo.md` - 根据待办清单变更情况决定是否执行
		- **触发条件**：
			- ✅ 有新增任务（如：步骤9发现的优化项）
			- ✅ 优先级调整（Critical问题提升优先级）
			- ✅ 任务完成归档（当前功能开发完成）
			- ✅ 任务逾期（需要标记逾期任务）
		- **非触发条件**：
			- ⏭️ 仅项目进度百分比变化
			- ⏭️ 无新增/完成/调整任务
- **更新内容**（自动化）：
	1. **项目状态文档**（`docs/项目状态.md`）- 追加模式
		- **当前阶段**：标记当前处于哪个步骤
		- **已完成功能**：列出本次迭代完成的功能模块
		- **进行中任务**：更新任务状态和进度
		- **代码统计**（NEW - 基于Git）：
			- 提交次数、代码变更量（+XXX / -XXX）
			- 活跃文件数、主要贡献者
		- **质量指标**（NEW - 整合步骤8/9）：
			- 测试覆盖率（整体/Service/Controller）
			- Bug数量（已修复/待修复）
			- 代码规范违规数（Critical/Major/Minor）
			- 安全漏洞数（高危/中危/低危）
		- **风险提示**（NEW）：
			- 识别的风险项
			- 严重程度评估
			- 应对措施建议
		- **技术决策**：记录重要的技术选型和架构决策
		- **下一步计划**：从待办清单提取最高优先级任务
	2. **待办清单文档**（`docs/待办清单.md`）**[智能判断是否更新]**
		- **自动更新**（基于Git提交）：
			- 标记已完成的任务为 `[x]`
			- 移动已完成任务到"✅ 已完成"区域
		- **优先级管理**：
			- 将步骤9发现的Critical问题标记为 `[!]` 紧急任务
			- 将Major问题添加为 `🟡 中优先级` 任务
			- 将Minor问题添加为 `🟢 低优先级` 任务
		- **进度跟踪**：
			- 更新进行中任务的进度（`[~]` + 百分比）
			- 标记逾期任务（`[*]` + 逾期天数）
		- **统计分析**：
			- 统计各优先级任务数量
			- 计算任务完成率
			- 识别阻塞任务
	3. **需求文档**（`docs/需求文档.md`）- 验收标准勾选
		- 勾选已完成的功能点验收标准
		- 记录实际实现与需求的差异（如有）
		- 标注延期或调整的功能
- **验证机制**（自动化）：
	- ✅ 检查所有验收标准是否已测试通过
	- ✅ 确认 Git 提交记录与文档描述一致
	- ✅ 验证进度计算准确性（已完成 / 总任务数）
	- ✅ 检查是否有遗漏的质量问题
	- ✅ 验证风险评估的合理性
- **协作智能体**：
	- **输入来自**：
		- `@test-engineer`（测试报告、覆盖率）
		- `@quality-inspector`（质量报告、问题清单）
		- `@code-reviewer`（代码审查问题）
	- **输出给**：
		- 用户（项目进度报告）
		- Git提交记录（作为commit message参考）
- **输出示例**：
	```
	✅ 项目文档更新完成
	
	执行命令:
	- update-status.md ✅ 已执行
	- update-todo.md ✅ 已执行 (新增3个待办任务)
	
	📊 项目进度统计:
	- 整体进度: 30% → 80% (↑ 50%)
	- 已完成: [步骤5] 数据库设计、[步骤6] 后端开发、[步骤7] 前端开发、[步骤8] 测试验证、[步骤9] 质量检查
	- 进行中: [步骤10] 文档更新 (95%)
	- 下一步: Git提交并合并到主分支
	
	💾 代码统计 (基于Git):
	- 提交次数: 8次
	- 代码变更: +1,245 / -38 行
	- 活跃文件: 15个
	- 主要模块: sport模块（运动记录管理）
	
	🎯 质量指标:
	- 测试覆盖率: 85% ✅ (Service: 92%, Controller: 88%)
	- Bug数量: 0个 ✅
	- 代码规范: 2个Major问题（已记录待办）
	- 安全漏洞: 1个中危漏洞（已评估不影响）
	
	⚠️ 风险提示:
	- 无高风险项 ✅
	
	📝 待办清单变更:
	- 新增任务: 3个
	  - [!] [紧急] 无
	  - [🟡] [中优先级] 2个（代码优化）
	  - [🟢] [低优先级] 1个（依赖升级）
	- 完成任务: 1个（运动记录功能开发）
	- 逾期任务: 0个 ✅
	
	📄 需求文档:
	- 验收标准: 8/8 已通过 ✅
	- 需求变更: 无
	
	✅ 所有文档已更新，可以继续执行步骤11（Git提交）
	```

---

## 步骤 11：Git 提交与合并（与步骤3闭环）

### 🔍 前置依赖检查

**必需检查项**:
- 🚫 文档已更新（必须先完成步骤10）
- 🚫 Git分支正确（必须在功能分支上提交）
- 🚫 有待提交的变更（检查git status）

**推荐检查项**: 无

**检查失败处理**:
- 必需项检查失败会暂停执行
- 系统会提示需要完成的前置步骤
- 如无待提交变更，会提示信息

**详细检查清单**: [dev-dependency-check.md - 步骤11](./dev-dependency-check.md#步骤11git提交)

---

### 执行内容
- **执行方式**：自动化Git提交、代码审查请求、分支合并流程
- **核心功能**：
	- **提交信息生成**：基于步骤10的进度报告自动生成规范的commit message
	- **变更验证**：验证是否满足提交条件（测试通过、质量检查通过、文档已更新）
	- **分支管理**：自动推送、创建PR/MR、管理分支生命周期
	- **冲突检测**：提前检测合并冲突并提供解决建议
	- **协作通知**：自动通知相关人员进行代码审查
- **📖 详细文档**：参见 [git-workflow-manager AGENT.md](../agents/git-workflow-manager/AGENT.md)（如已实现）
- **前置检查**（自动执行）：
	- ✅ 验证步骤8测试已通过
	- ✅ 验证步骤9质量检查已通过
	- ✅ 验证步骤10文档已更新
	- ✅ 检查是否有未提交的文件
	- ✅ 检查是否有敏感信息（.env、密钥等）
- **执行流程**：
	- **11.1 智能提交信息生成**（自动化）
		```
		执行步骤：
		1. 从步骤10的进度报告中提取：
		   - 已完成功能
		   - 代码变更统计
		   - 质量指标
		
		2. 生成符合规范的commit message：
		   格式：<type>(<scope>): <subject>
		   
		   示例：
		   feat(sport): 新增运动记录管理功能
		   
		   - 实现运动记录的增删改查
		   - 添加运动统计分析功能
		   - 完善数据权限控制
		   
		   测试覆盖率: 85%
		   代码变更: +1,245 / -38 行
		   测试用例: 45个全部通过
		   质量评级: B+
		
		3. type类型自动判断：
		   - feat: 新增功能（新模块、新接口）
		   - fix: 修复Bug（问题修复）
		   - docs: 文档更新（仅文档变更）
		   - style: 代码格式（不影响功能）
		   - refactor: 重构代码（优化现有代码）
		   - test: 测试相关（新增测试）
		   - chore: 构建过程或辅助工具
		```
	
	- **11.2 代码暂存与提交**（自动执行）
		```bash
		# 1. 查看当前修改状态
		git status
		
		# 2. 智能添加文件（排除敏感文件）
		# 自动检测并排除：
		# - .env, .env.*
		# - *.key, *.pem
		# - application-*.yml (如包含密钥)
		git add .
		
		# 3. 提交代码（使用自动生成的message）
		git commit -m "$(cat <<'EOF'
		feat(sport): 新增运动记录管理功能
		
		- 实现运动记录的增删改查
		- 添加运动统计分析功能
		- 完善数据权限控制
		
		测试覆盖率: 85%
		代码变更: +1,245 / -38 行
		测试用例: 45个全部通过
		质量评级: B+
		EOF
		)"
		```
	- **11.3 推送到远程仓库**（自动执行）
		```bash
		# 1. 检测冲突
		git fetch origin
		git diff origin/main..HEAD  # 检查差异
		
		# 2. 推送当前功能分支到远程
		git push -u origin feature/[功能名]
		
		# 3. 输出推送结果
		分支推送成功 ✅
		远程分支: origin/feature/sport-record
		提交数量: 8个
		代码变更: +1,245 / -38 行
		```
	
	- **11.4 创建 Pull Request / Merge Request**（自动化）
		- **方式 A：使用 GitHub CLI（推荐）**
			```bash
			# 自动创建PR
			gh pr create \
			  --title "feat(sport): 新增运动记录管理功能" \
			  --body "$(cat <<'EOF'
			## 📋 功能说明
			新增运动记录管理模块，支持运动数据的增删改查和统计分析。
			
			## ✅ 完成内容
			- [x] 后端API开发（Controller/Service/Mapper）
			- [x] 前端页面开发（列表/表单/统计）
			- [x] 单元测试和接口测试（45个测试用例）
			- [x] 代码质量检查（质量评级：B+）
			- [x] 文档更新（需求文档、API文档）
			
			## 📊 质量指标
			- 测试覆盖率: 85% ✅
			  - Service层: 92%
			  - Controller层: 88%
			- Bug数量: 0个 ✅
			- 代码规范: 2个Minor问题（已记录待办）
			- 安全漏洞: 无 ✅
			
			## 📝 代码变更
			- 提交次数: 8次
			- 代码变更: +1,245 / -38 行
			- 活跃文件: 15个
			
			## 🔍 审查重点
			- [ ] 运动记录的业务逻辑
			- [ ] 统计分析功能的准确性
			- [ ] 数据权限控制
			- [ ] 接口性能
			
			## 📄 相关文档
			- 需求文档: docs/需求文档.md
			- API文档: docs/API文档.md
			- 测试报告: target/site/surefire-report.html
			
			EOF
			)" \
			  --assignee @me \
			  --label "enhancement,documentation"
			
			# 输出PR链接
			PR已创建 ✅
			PR链接: https://github.com/org/repo/pull/123
			```
		
		- **方式 B：使用 GitLab CLI**
			```bash
			# 自动创建MR
			glab mr create \
			  --title "feat(sport): 新增运动记录管理功能" \
			  --description "$(cat merge_request_template.md)" \
			  --label "feature,needs-review"
			```
		
		- **方式 C：直接合并（仅个人项目或小团队）**
			```bash
			# 1. 检查是否可以直接合并
			if [ -z "$(git log origin/main..HEAD)" ]; then
			  echo "⚠️ 没有新提交，跳过合并"
			  exit 0
			fi
			
			# 2. 切换到主分支
			git checkout main
			
			# 3. 拉取最新代码
			git pull origin main
			
			# 4. 检测冲突
			git merge --no-commit --no-ff feature/[功能名]
			if [ $? -ne 0 ]; then
			  echo "❌ 检测到合并冲突，请手动解决"
			  git merge --abort
			  exit 1
			fi
			
			# 5. 执行合并
			git merge feature/[功能名]
			
			# 6. 推送到远程
			git push origin main
			
			# 7. 删除本地和远程功能分支
			git branch -d feature/[功能名]
			git push origin --delete feature/[功能名]
			
			echo "✅ 合并完成"
			```
	
	- **11.5 协作智能体**（自动化）
		```
		协作流程：
		1. @project-manager 提供进度报告
		   ↓
		2. @git-workflow-manager 生成commit message
		   ↓
		3. 自动执行Git提交和推送
		   ↓
		4. 自动创建PR/MR
		   ↓
		5. [可选] 自动通知团队审查
		   ↓
		6. 审查通过后自动合并（如配置）
		```
- **⚠️ 注意事项**：
	- 提交前确保代码已通过测试（步骤 8）
	- 提交前确保代码质量检查通过（步骤 9）
	- 提交前确保文档已更新（步骤 10）
	- 提交信息需清晰描述本次修改内容
	- 避免提交敏感信息（`.env`、密钥等）
	- 合并前解决所有代码冲突
- **✅ 闭环检查清单**：
	- [ ] 功能分支已从 `main` 创建（步骤 3）
	- [ ] 文档已在功能分支上初始化（步骤 4）
	- [ ] 代码开发已完成（步骤 5-7）
	- [ ] 测试验证已通过（步骤 8）
	- [ ] 代码质量检查已通过（步骤 9）
	- [ ] 文档已同步更新（步骤 10）
	- [ ] 代码已提交并推送到远程
	- [ ] 功能分支已合并到 `main`
	- [ ] 本地和远程功能分支已清理（可选）
- **⚠️ 失败处理**：
	- 🤖 **自动回滚**（L1级别）：pre-commit钩子拒绝时自动格式化并重新提交，最多2次
	- ⚠️ **需用户确认**（L3级别）：合并冲突需手动解决
	- 📖 **详细说明**：参见 [回滚决策树 - 步骤11](./dev-rollback-guide.md#步骤11失败git提交)
