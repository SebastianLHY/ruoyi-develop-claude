# ❓ 常见问题与优化建议

> **版本**: v2.18.0  
> **所属**: dev.md v2.18.0  
> **用途**: 9个常见问题的解决方案  
> **最后更新**: 2026-01-29

---

## Q1: 如何判断是否需要新建模块？

**判断标准**：
- 业务领域独立（如订单、库存、运动健康等）→ 新建模块`ruoyi-business`
- 属于系统管理功能（用户、角色、菜单等）→ 使用 `ruoyi-system`
- 仅为演示或测试功能 → 使用 `ruoyi-demo`

**示例**：
| 功能 | 建议模块 | 理由 |
|------|---------|------|
| 用户管理 | ruoyi-system | 系统管理功能 |
| 订单管理 | ruoyi-business（新建） | 业务领域独立 |
| 测试功能 | ruoyi-demo | 演示或测试 |
| 运动记录 | ruoyi-business（新建） | 业务领域独立 |

---

## Q2: 文档初始化后发现需求变更怎么办？

**处理方式**：
1. 立即更新 `docs/需求文档.md`
2. 重新评估技术设计（步骤2）
3. 更新 `docs/项目状态.md` 中的任务清单
4. 在 Git 提交时注明需求变更原因

**示例流程**：
```bash
# 1. 更新需求文档
# 编辑 docs/需求文档.md

# 2. 重新评估技术设计
# 如需修改表结构，更新步骤2的设计方案

# 3. 更新项目状态
# 编辑 docs/项目状态.md，记录变更原因

# 4. 提交变更
git add docs/
git commit -m "docs: 需求变更 - 增加XX字段"
```

---

## Q3: 测试验证阶段发现Bug怎么处理？

**处理流程**：
1. 激活 `bug-detective` 技能进行问题定位
2. 修复代码后重新运行测试
3. 在 `docs/项目状态.md` 中记录Bug和修复方案
4. 单独提交一次 Git Commit（类型：fix）

**示例**：
```bash
# 1. 定位问题
# 使用 bug-detective 技能分析日志和堆栈信息

# 2. 修复代码
# 修改相关文件

# 3. 重新测试
mvn test

# 4. 记录到文档
# 编辑 docs/项目状态.md

# 5. 提交修复
git add .
git commit -m "fix: 修复用户登录时空指针异常"
```

---

## Q4: 如何提高开发效率？

**优化建议**：
1. **步骤1-2合并执行**（边澄清需求边设计方案）
   - 节省时间：约20%
   - 适用场景：需求相对明确的情况
   
2. **步骤5-6并行**（数据库设计完成后立即生成Entity）
   - 节省时间：约15%
   - 适用场景：表结构确定后

3. **使用代码生成器**（若依自带的代码生成功能）
   - 节省Token：约40%
   - 节省时间：约50%
   - 适用场景：标准CRUD功能

4. **前端页面基于现有模板快速改造**
   - 节省时间：约30%
   - 适用场景：页面布局相似的功能

**效率对比**：
| 方式 | 时间消耗 | Token消耗 | 适用场景 |
|------|---------|----------|---------|
| 标准流程 | 100% | 100% | 所有场景 |
| 合并步骤1-2 | 80% | 95% | 需求明确 |
| 使用代码生成器 | 50% | 60% | 标准CRUD |
| 复用模板 | 70% | 70% | 相似功能 |

---

## Q5: Token消耗过大怎么办？

**优化策略**（按效果排序）：

### 1. 使用若依代码生成器（步骤2.5）⭐⭐⭐⭐⭐
- ✅ 效果最佳：可节省约40%整体Token消耗
- ✅ 适用场景：标准CRUD功能
- ⚠️ 需要：用户手动操作代码生成器

### 2. 分批执行 ⭐⭐⭐⭐
- 先完成步骤1-6（后端），再执行步骤7（前端）
- 可节省约20% Token（避免上下文重复加载）

### 3. 跳过已完成步骤 ⭐⭐⭐
- 如果项目已有Git管理，跳过步骤3的初始化部分
- 如果文档已存在，跳过步骤4

### 4. 使用精简模式 ⭐⭐
- 对于简单CRUD功能，可以省略测试代码生成（步骤8）
- 对于原型验证项目，可以暂时跳过步骤9（质量检查）

### 5. 复用现有代码 ⭐⭐⭐⭐⭐
- 参考项目中已有的类似功能，复制并修改
- 比完全重新生成节省约50% Token

**Token消耗对比**：
| 策略 | Token节省 | 实施难度 | 推荐度 |
|------|----------|---------|--------|
| 代码生成器 | 40% | 低 | ⭐⭐⭐⭐⭐ |
| 复用代码 | 50% | 中 | ⭐⭐⭐⭐⭐ |
| 分批执行 | 20% | 低 | ⭐⭐⭐⭐ |
| 跳过步骤 | 10% | 低 | ⭐⭐⭐ |
| 精简模式 | 15% | 中 | ⭐⭐ |

---

## Q6: 为什么要先Git初始化再文档初始化？

**原因说明**：
- v2.0版本：文档初始化在Git初始化前，可能导致文档提交到错误分支
- v2.1版本：调整顺序后，确保文档从一开始就在功能分支上

**好处**：
- ✅ 避免文档污染主分支
- ✅ 功能分支包含完整的需求和开发记录
- ✅ 代码审查时可以同时审查文档

**流程对比**：
```
v2.0（错误）:
步骤3: 文档初始化（在main分支）
步骤4: Git初始化（创建feature分支）
问题: 文档在main分支，代码在feature分支

v2.1+（正确）:
步骤3: Git初始化（创建feature分支）
步骤4: 文档初始化（在feature分支）
优势: 文档和代码都在feature分支
```

---

## Q7: 代码质量检查失败怎么办？

**处理策略**：

### 1. Critical 问题（阻断）🔴
- **处理方式**：必须立即修复，不允许继续
- **修复后**：重新执行步骤9
- **示例**：
  - 空指针异常
  - SQL注入漏洞
  - 死循环

### 2. Major 问题（警告）🟡
- **处理方式**：评估影响，优先修复重要问题
- **可接受标准**：< 5个问题继续提交
- **未修复问题**：记录到待办清单
- **示例**：
  - 方法复杂度过高
  - 代码重复
  - 命名不规范

### 3. Minor 问题（优化）🟢
- **处理方式**：记录到待办清单
- **修复时机**：在后续迭代中优化
- **示例**：
  - 注释不完整
  - 日志级别不当
  - 代码格式问题

### 4. 依赖漏洞 ⚠️
- **高危漏洞**：必须升级或替换依赖
- **中危漏洞**：评估是否影响当前使用场景
- **低危漏洞**：记录并计划升级

**处理流程图**：
```
代码质量检查
    ↓
发现问题
    ↓
├─ Critical → 立即修复 → 重新检查
├─ Major → 评估影响 → 修复重要问题 → 记录其他
├─ Minor → 记录到待办清单 → 后续优化
└─ 依赖漏洞 → 按危险等级处理
```

---

## Q8: 某个步骤失败了怎么办？

⚠️ **重要**: 本FAQ提供快速参考，**完整的回滚决策树和异常处理流程请参见**：  
📖 **[dev-rollback-guide.md](./dev-rollback-guide.md)** - P0改进文档 🆕

---

### 快速参考（简化版）

| 失败步骤 | 常见原因 | 回滚级别 | 详细处理 |
|---------|---------|---------|---------|
| **步骤1** | 需求不明确 | L1 轻微 | [查看详细处理](./dev-rollback-guide.md#步骤1失败需求澄清) |
| **步骤2** | 技术方案错误 | L1-L3 | [查看详细处理](./dev-rollback-guide.md#步骤2失败技术设计) |
| **步骤3** | Git初始化失败 | L1 轻微 | [查看详细处理](./dev-rollback-guide.md#步骤3失败git初始化) |
| **步骤5** | SQL执行失败 | L1-L2 | [查看详细处理](./dev-rollback-guide.md#步骤5失败数据库设计) |
| **步骤5.5** | 生成器配置错误/超时 | L1 轻微 | [查看详细处理](./dev-rollback-guide.md#步骤55失败代码生成方式选择) |
| **步骤6** | 代码编译/审查失败 | L1-L3 | [查看详细处理](./dev-rollback-guide.md#步骤6失败后端开发) |
| **步骤8** | 测试失败 | L1-L2 | [查看详细处理](./dev-rollback-guide.md#步骤8失败测试验证) |
| **步骤9** | 质量检查不通过 | L1-L2 | [查看详细处理](./dev-rollback-guide.md#步骤9失败代码质量检查) |
| **步骤11** | Git提交冲突/失败 | L1-L2 | [查看详细处理](./dev-rollback-guide.md#步骤11失败git提交) |

---

### 回滚级别说明

| 级别 | 描述 | 影响范围 | 用户确认 |
|------|------|---------|---------|
| **L1 - 轻微** | 仅回滚当前步骤 | 单个文件或配置 | ✅ 必需 |
| **L2 - 中等** | 回滚到上一步骤 | 多个文件 | ✅ 必需 |
| **L3 - 重大** | 回滚到设计阶段 | 整个模块 | ✅ 必需 + 原因说明 |
| **L4 - 完全** | 重置整个流程 | 所有代码和文档 | ✅ 必需 + 二次确认 |

---

### 智能体异常处理（NEW）

#### 智能体调用超时
```yaml
超时配置：
  单次调用: 30秒
  重试次数: 3次
  重试间隔: 1s, 2s, 4s（指数退避）
  
超时后降级：
  @code-reviewer 超时 → 人工审查清单
  @test-engineer 超时 → 基础测试框架
  @quality-inspector 超时 → 人工检查清单
  @bug-detective 超时 → 基础调试建议
```

📖 **详细处理**: [智能体异常处理](./dev-rollback-guide.md#智能体异常处理)

#### 智能体协作失败
```markdown
场景1: @code-generator → @code-reviewer失败
→ 降级到人工审查清单
→ 提供审查要点

场景2: 步骤8 → 步骤9数据传递失败
→ 重新生成报告
→ 独立执行检查
```

📖 **详细处理**: [智能体协作失败](./dev-rollback-guide.md#智能体协作失败)

---

### 常见场景快速跳转

1. **[代码生成后发现表结构错误](./dev-rollback-guide.md#场景1-代码生成后发现表结构设计错误)**
2. **[测试失败，多次修复仍无法通过](./dev-rollback-guide.md#场景2-测试失败多次修复仍无法通过)**
3. **[质量检查发现大量问题](./dev-rollback-guide.md#场景3-质量检查发现大量问题)**
4. **[Git提交后发现遗漏关键功能](./dev-rollback-guide.md#场景4-git提交后发现遗漏关键功能)**

---

### 通用回滚命令（精简版）

```bash
# Git回滚（未提交）
git checkout -- .           # 回滚所有修改
git clean -fd               # 删除未跟踪文件

# Git回滚（已提交未推送）
git reset --soft HEAD~1     # 保留修改
git reset --hard HEAD~1     # 丢弃修改

# 数据库回滚
DROP TABLE IF EXISTS <表名>;

# 文件备份与删除
mkdir -p backup/$(date +%Y%m%d_%H%M%S)
cp -r <目录> backup/$(date +%Y%m%d_%H%M%S)/
rm -rf <目录>
```

📖 **完整命令库**: [回滚执行命令](./dev-rollback-guide.md#回滚执行命令)

---

### ⚠️ 回滚前必读检查清单

```markdown
□ 1. 用户明确确认回滚操作
□ 2. 数据备份完成
□ 3. 影响范围明确
□ 4. 回滚命令准备
□ 5. 恢复计划明确
□ 6. 文档记录准备
□ 7. 团队协调（如需要）
```

📖 **完整清单**: [回滚检查清单](./dev-rollback-guide.md#回滚检查清单)

---

### 📚 扩展阅读

想要了解更多？查看完整的回滚决策树文档：

- 📖 **[完整回滚决策树](./dev-rollback-guide.md)** - 12步骤完整回滚策略
- 🗺️ **[回滚决策矩阵](./dev-rollback-guide.md#回滚决策矩阵)** - 快速决策表
- 🔧 **[分步骤回滚指南](./dev-rollback-guide.md#分步骤回滚指南)** - 详细处理流程
- 🤖 **[智能体异常处理](./dev-rollback-guide.md#智能体异常处理)** - 7个智能体的异常处理
- 💻 **[回滚执行命令](./dev-rollback-guide.md#回滚执行命令)** - Git/数据库/文件命令库
- 🎯 **[常见场景处理](./dev-rollback-guide.md#常见场景处理)** - 4个典型场景完整流程

---

## Q9: 用户自行修改代码后如何智能处理？

**适用场景**：
- 用户（如Cursor）直接修改了代码文件
- 未按照标准流程执行
- AI需要理解用户意图并规范化处理

---

### 🤖 AI智能处理流程

#### 阶段1：意图识别与理解

**AI自动执行**（无需用户确认）：

1. **检测代码变更**
   ```bash
   # 检查Git状态（如有Git管理）
   git status
   git diff
   
   # 或扫描最近修改的文件
   # 识别修改的文件类型（Entity/Mapper/Service/Controller/Vue等）
   ```

2. **分析修改内容**
   - 识别修改类型：
     - 🆕 新增功能（新文件、新方法）
     - 🔧 修复Bug（修改现有逻辑）
     - 📝 代码优化（重构、性能优化）
     - 📋 注释/文档更新
   - 识别修改范围：
     - 数据层（Entity/Mapper）
     - 业务层（Service）
     - 控制层（Controller）
     - 前端（Vue/API）

3. **尝试理解用户意图**
   
   **AI内部推理**（不输出给用户）：
   ```
   - 是否与现有需求文档一致？
   - 是否为新增功能需求？
   - 是否为Bug修复？
   - 是否为代码优化？
   ```

---

#### 阶段2：用户确认（仅不明确时）

**触发条件**：AI无法确定明确意图时

**询问方式**：
```
🔍 检测到您修改了以下文件：
- [列出修改的文件及核心变更点]

💡 初步判断：[AI的理解，如："您可能在添加XX功能"]

请确认您的修改意图：
1. [新增功能] - 新增XX功能（描述）
2. [修复Bug] - 修复XX问题
3. [代码优化] - 优化XX性能/结构
4. [其他] - 请手动描述

请选择 [1/2/3/4] 或直接描述意图：
```

**用户回答后记录**：
- 保存用户意图到临时上下文
- 用于后续文档更新

---

#### 阶段3：代码复查

**AI执行的检查项**：

##### 3.1 功能完整性检查

```
✅ 检查项：
- [ ] 前后端代码是否匹配（API路径、参数、返回值）
- [ ] 数据库表结构是否支持（字段是否存在）
- [ ] 业务逻辑是否完整（CRUD是否齐全）
- [ ] 权限控制是否添加（@SaCheckPermission）
- [ ] 关联关系是否处理（外键、级联查询）

⚠️ 发现问题：
- [列出缺失或不一致的地方]

💡 建议补充：
- [列出需要补充的代码]
```

##### 3.2 代码规范检查

```
✅ 规范检查：
- [ ] 命名规范（类名、方法名、变量名）
- [ ] 注释完整性（类、方法、字段JavaDoc）
- [ ] 代码格式（缩进、换行、空格）
- [ ] 若依框架规范（继承BaseEntity、使用LambdaQueryWrapper等）
- [ ] 异常处理（try-catch、事务回滚）

⚠️ 规范问题：
- [列出不符合规范的地方]

💡 建议修改：
- [提供修改建议或直接修改]
```

##### 3.3 代码质量检查

```
✅ 质量检查：
- [ ] 安全性（SQL注入、XSS防护、参数校验）
- [ ] 性能（避免N+1查询、分页处理、索引使用）
- [ ] 可维护性（方法长度、复杂度、代码重复）
- [ ] 测试覆盖（是否需要补充测试）

⚠️ 质量问题：
- [列出潜在问题]

💡 优化建议：
- [提供优化方案]
```

---

#### 阶段4：Git分支管理

**检查Git状态**：

```bash
# 1. 检查是否有Git管理
if [ -d ".git" ]; then
    # 2. 检查当前分支
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    # 3. 判断是否在主分支
    if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
        # 需要迁移到功能分支
        echo "⚠️ 需要迁移到功能分支"
    else
        # 已在功能分支
        echo "✅ 已在功能分支 $current_branch"
    fi
else
    echo "⚠️ 项目未进行Git版本管理"
fi
```

**处理策略**：

##### 情况A：在主分支修改（需要迁移）

```
⚠️ 检测到您在主分支(main)上修改了代码

根据开发规范，将为您自动迁移到功能分支：

执行操作：
1. 暂存当前修改
2. 创建功能分支 feature/[根据意图生成分支名]
3. 恢复修改到功能分支

是否执行自动迁移？[是/否]
```

**用户同意后执行**：
```bash
# 1. 暂存修改
git stash save "AI自动迁移: [用户意图描述]"

# 2. 创建并切换到功能分支
git checkout -b feature/[功能名]

# 3. 恢复修改
git stash pop

# 4. 提示用户
echo "✅ 已迁移到功能分支 feature/[功能名]"
```

##### 情况B：已在功能分支（无需迁移）

```
✅ 检测到您已在功能分支 [分支名]
无需迁移，继续当前分支开发
```

##### 情况C：无Git管理（提醒用户）

```
⚠️ 项目未进行Git版本管理

建议：
1. [推荐] 立即初始化Git并创建功能分支
2. [继续] 暂不使用Git版本控制

请选择 [1/2]:
```

---

#### 阶段5：文档同步更新

**AI自动执行**（基于阶段2的用户意图）：

##### 5.1 更新项目状态文档

```markdown
# docs/项目状态.md

## 📊 项目进度
- 整体进度：[根据修改内容更新百分比]
- 当前状态：开发中
- 最后更新：[当前时间]

## 📝 最近变更
### [日期] - [用户意图标题]
- **变更类型**：[新增功能/Bug修复/代码优化]
- **修改文件**：
  - [列出修改的文件]
- **核心变更**：
  - [描述核心修改内容]
- **影响范围**：
  - [描述影响的模块/功能]
- **Git提交**：feature/[分支名] ([提交SHA，如已提交])

## ⚠️ 发现的问题（如有）
- [列出阶段3发现的问题]
- [优先级标注]
```

##### 5.2 更新待办清单文档

**触发条件**：阶段3发现问题或需要补充工作

```markdown
# docs/待办清单.md

## 🔥 高优先级待办（新增）
- [ ] [补充XX功能] - 来自代码复查（[日期]）
- [ ] [修复XX规范问题] - 来自代码复查（[日期]）
- [ ] [优化XX性能问题] - 来自代码复查（[日期]）

## ✅ 最近完成
- [✓] [用户完成的修改] - 完成时间：[日期]
```

##### 5.3 更新需求文档（如为新功能）

**触发条件**：用户意图为"新增功能"且需求文档中无对应条目

```markdown
# docs/需求文档.md

## 📋 功能需求清单
### [新增] REQ-[编号]: [功能名称]
- **优先级**：[根据用户说明判断]
- **状态**：开发中
- **描述**：[根据代码变更推断功能描述]
- **验收标准**：
  - [ ] [根据代码推断验收标准]
- **备注**：用户自行开发，AI已复查
```

---

### 🎯 完整处理示例

**场景**：用户修改了 `UserService.java`，新增了 `getUserByPhone` 方法

```
1️⃣ 意图识别：
   - 检测到修改：UserService.java（新增方法）
   - AI理解：可能在添加"通过手机号查询用户"功能

2️⃣ 用户确认：
   AI: "检测到您新增了 getUserByPhone 方法，是否在添加通过手机号查询用户功能？"
   用户: "是的"

3️⃣ 代码复查：
   ✅ 方法签名正确
   ✅ 返回类型正确
   ⚠️ 发现问题：
       - Controller层未添加对应接口
       - 数据库phone字段缺少索引
       - 缺少JavaDoc注释
   
   AI: "发现3个问题，已记录到待办清单，是否立即修复？"

4️⃣ Git分支管理：
   - 检测到在main分支
   - AI: "将为您迁移到 feature/user-query-by-phone 分支"
   - 执行自动迁移

5️⃣ 文档更新：
   - 更新项目状态：新增"通过手机号查询用户"功能（80%）
   - 更新待办清单：
     - [ ] 补充Controller接口
     - [ ] 添加phone字段索引
     - [ ] 补充JavaDoc注释
   - 更新需求文档：新增REQ-005功能条目

6️⃣ 输出总结：
   """
   ✅ 代码理解与复查完成
   
   📋 您的修改：
   - 新增功能：通过手机号查询用户
   - 修改文件：UserService.java
   
   ✅ 已完成：
   - 代码复查通过（发现3个待优化项）
   - 迁移到功能分支 feature/user-query-by-phone
   - 更新项目文档
   
   📝 待办任务：
   1. [高优先级] 补充Controller接口
   2. [高优先级] 添加phone字段索引
   3. [中优先级] 补充JavaDoc注释
   
   💡 下一步建议：
   是否立即修复待办任务？[是/手动处理]
   """
```

---

### ⚙️ 配置选项（可选）

**用户可设置AI处理偏好**：

```yaml
# .claude/config.yml（可选）

code_review:
  # 自动复查级别
  auto_review_level: "standard"  # minimal / standard / strict
  
  # 自动迁移分支
  auto_migrate_branch: true      # true / false（需用户确认）
  
  # 自动更新文档
  auto_update_docs: true         # true / false
  
  # 自动修复规范问题
  auto_fix_style: true           # true / false（自动修复格式、注释等）
  
  # 是否询问用户意图
  ask_intent_when_unclear: true  # true / false（false时AI自行判断）
```

---

### 📊 处理流程对比

| 阶段 | 标准流程（AI主导） | 用户自行修改流程（AI辅助） |
|------|------------------|------------------------|
| 需求澄清 | ✅ AI询问 | ⚡ AI推断+确认 |
| 技术设计 | ✅ AI设计 | ⚡ AI复查+补充 |
| 代码生成 | ✅ AI生成 | ⚡ AI复查+优化 |
| 分支管理 | ✅ AI创建 | ⚡ AI检测+迁移 |
| 文档更新 | ✅ AI填写 | ⚡ AI同步更新 |

---

## Q10: 新建模块时 pom.xml 未创建怎么办？

**现象**：
- 新建 ruoyi-business 模块后，发现 pom.xml 文件不存在
- Maven 无法识别该模块
- 编译时报错找不到模块

**原因**：
- 步骤执行时遗漏了 pom.xml 创建步骤

**自动处理机制**：
从 v2.18.0 开始，系统会在代码生成前自动检查并补充创建：

```
前置检查（自动执行）：
1. 检查模块 pom.xml 是否存在
2. 如不存在 → 自动创建标准 pom.xml
3. 检查父 pom.xml 是否已注册模块
4. 如未注册 → 自动添加模块引用
5. 验证通过后才继续生成代码
```

**手动处理方式**：

如遇到此问题，可以明确告诉AI：
```
请检查 ruoyi-modules/ruoyi-business/pom.xml 是否存在，
如不存在，请立即创建标准 pom.xml 并更新父 pom.xml
```

AI会自动执行：
1. 创建模块 pom.xml（包含必需依赖）
2. 更新父 pom.xml 注册模块
3. 验证配置是否正确

**预防措施**：
- ✅ 系统已在步骤6开始前增加强制检查
- ✅ code-generator 智能体会自动验证
- ✅ 如有缺失会立即补充创建

---

## 💡 最佳实践总结

### 效率优化
1. ⭐⭐⭐⭐⭐ 使用代码生成器（节省40% Token）
2. ⭐⭐⭐⭐⭐ 复用现有代码（节省50% Token）
3. ⭐⭐⭐⭐ 分批执行（节省20% Token）

### 质量保障
1. ⭐⭐⭐⭐⭐ 步骤8测试验证（覆盖率>80%）
2. ⭐⭐⭐⭐⭐ 步骤9质量检查（无Critical问题）
3. ⭐⭐⭐⭐ 步骤10文档同步（保持一致性）

### 风险管理
1. ⭐⭐⭐⭐⭐ 模块归属前置（步骤2确定）
2. ⭐⭐⭐⭐ Git分支隔离（步骤3创建）
3. ⭐⭐⭐⭐ 回滚机制（Q8参考）
4. ⭐⭐⭐⭐⭐ 智能代码复查（Q9，用户自行修改时）
5. ⭐⭐⭐⭐⭐ 模块配置自动检查（Q10，pom.xml自动创建）
