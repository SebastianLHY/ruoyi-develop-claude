# 🔄 回滚决策树与异常处理指南

> **版本**: v2.18.0  
> **所属**: dev.md v2.18.0  
> **优先级**: P0 - 容错性核心改进  
> **用途**: 提供完整的回滚决策树和自动回滚机制  
> **创建日期**: 2026-01-29  
> **最后更新**: 2026-01-29 - v2.18.0综合增强版本

---

## 📋 目录

- [概述](#概述)
- [自动回滚机制](#自动回滚机制) 🆕
- [检查点与断点续传](#检查点与断点续传) 🆕
- [回滚决策矩阵](#回滚决策矩阵)
- [分步骤回滚指南](#分步骤回滚指南)
- [智能体异常处理](#智能体异常处理)
- [回滚执行命令](#回滚执行命令)
- [常见场景处理](#常见场景处理)

---

## 📊 概述

### 回滚原则

1. **安全优先**: 回滚前必须确认不会丢失重要数据
2. **自动化优先**: 符合条件的失败自动触发回滚，无需用户确认 🆕
3. **用户确认**: 重大回滚操作（L3/L4）必须经过用户明确确认
4. **文档记录**: 回滚原因和过程必须记录到项目状态文档
5. **根因分析**: 回滚后必须分析失败原因，避免重复问题

### 回滚级别

| 级别 | 描述 | 影响范围 | 用户确认 | 自动回滚 🆕 |
|------|------|---------|---------|------------|
| **L1 - 轻微** | 仅回滚当前步骤 | 单个文件或配置 | ⚡ 自动执行 | ✅ 支持 |
| **L2 - 中等** | 回滚到上一步骤 | 多个文件 | ⚡ 自动执行 | ✅ 支持 |
| **L3 - 重大** | 回滚到设计阶段 | 整个模块 | ✅ 必需 + 原因说明 | ❌ 不支持 |
| **L4 - 完全** | 重置整个流程 | 所有代码和文档 | ✅ 必需 + 二次确认 | ❌ 不支持 |

---

## 🤖 自动回滚机制 🆕

### 核心理念

**自动化容错，减少人工干预，提升开发效率**

- ✅ **L1/L2级别失败自动回滚**：无需用户确认，AI自动执行回滚和修复
- ⚠️ **L3/L4级别需要确认**：影响范围大，必须用户明确确认
- 📝 **全程记录**：所有回滚操作自动记录到项目状态文档
- 🔄 **智能重试**：回滚后自动分析失败原因，调整策略重新执行

---

### 自动回滚触发条件

| 步骤 | 触发条件 | 回滚级别 | 自动操作 | 重试策略 |
|------|---------|---------|---------|---------|
| **步骤1** | 需求不明确 | L1 | 重新提问 | 最多3次 |
| **步骤2** | 技术方案错误（仅设计阶段） | L1 | 重新设计 | 最多2次 |
| **步骤5** | SQL语法错误 | L1 | 修正SQL → 重新执行 | 最多3次 |
| **步骤5.5** | 生成器超时 | L1 | 切换AI生成 | 自动切换 |
| **步骤6** | 代码编译错误 | L1 | 修正代码 → 重新编译 | 最多3次 |
| **步骤6** | @code-reviewer发现Critical | L2 | 自动修复 → 重新审查 | 最多3次 |
| **步骤7** | 前端编译错误 | L1 | 修正代码 → 重新编译 | 最多3次 |
| **步骤7** | @code-reviewer发现Critical | L2 | 自动修复 → 重新审查 | 最多3次 |
| **步骤8** | 单元测试失败(Minor) | L1 | 修正代码 → 重新测试 | 最多3次 |
| **步骤9** | Critical问题 | L2 | 自动修复 → 重新检查 | 最多3次 |
| **步骤11** | pre-commit钩子拒绝 | L1 | 自动格式化 → 重新提交 | 最多2次 |

**不支持自动回滚的场景**（需用户确认）:
- ❌ 步骤2失败且已执行步骤5+（L3级别）
- ❌ 步骤8测试失败(Critical) - 需激活@bug-detective
- ❌ 步骤9 Major问题>10个 - 需用户决策
- ❌ 步骤11合并冲突 - 需手动解决

---

### 自动回滚执行流程（含检查点）

```mermaid
步骤执行失败
    ↓
[检查点] 保存失败前状态 🆕
    ↓
判断失败级别
    ↓
L1/L2级别? ──────────────────────────────┐
    ├─ 是 ↓                               │
    │  自动回滚机制启动                    │
    │  ├─ 1. 加载上一个检查点 🆕           │
    │  ├─ 2. 自动备份当前状态              │
    │  ├─ 3. 执行回滚操作                  │
    │  ├─ 4. 分析失败原因                  │
    │  ├─ 5. 调整策略                      │
    │  ├─ 6. 自动重试                      │
    │  └─ 7. 记录回滚日志                  │
    │      ↓                               │
    │  重试成功? ──────────────────────┐   │
    │      ├─ 是 ↓                     │   │
    │      │  [检查点] 保存成功状态 🆕 │   │
    │      │  继续下一步骤 ────────────┤   │
    │      └─ 否 ↓                     │   │
    │         重试次数<上限?            │   │
    │             ├─ 是 → 继续重试     │   │
    │             └─ 否 → 升级为L3 ────┼───┘
    │                                  │
    └─ 否 ↓                            │
       L3/L4级别                       │
       ├─ 1. 暂停流程                  │
       ├─ 2. 列出可用检查点 🆕          │
       ├─ 3. 生成回滚方案              │
       ├─ 4. 询问用户确认 ←────────────┘
       ├─ 5. 用户确认后执行
       ├─ 6. 恢复到选定检查点 🆕
       └─ 7. 记录回滚日志
```

---

### 自动回滚示例

#### 示例1: 步骤6编译错误（L1自动回滚）

```markdown
❌ 检测到编译错误

错误信息:
SportRecordServiceImpl.java:45: error: cannot find symbol
    return record.getName();
                  ^
  symbol:   method getName()
  location: variable record of type SportRecord

💾 [检查点] 保存失败前状态 ✅
- 检查点ID: cp_before_failure_20260129_153045
- 保存内容: 步骤6未完成状态

🤖 自动回滚机制启动

[1/7] 加载上一个检查点 ✅
- 检查点: cp_20260129_152000_step5 (步骤5完成)
- 状态: 数据库设计已完成

[2/7] 备份当前状态 ✅
- 备份路径: backup/compile-error-20260129-153045/

[3/7] 执行回滚操作 ✅
- 回滚级别: L1（轻微）
- 回滚范围: SportRecordServiceImpl.java

[4/7] 分析失败原因 ✅
根因: Entity类缺少getName()方法
建议: 在SportRecord实体类中添加getName()方法

[5/7] 调整策略 ✅
修复方案: 在SportRecord.java中添加缺失的getter方法

[6/7] 自动修复并重试 ✅
- 修复代码: 添加getName()方法
- 重新编译: mvn clean compile
- 编译结果: ✅ 成功

[7/7] 记录回滚日志 ✅
- 日志路径: docs/项目状态.md

💾 [检查点] 保存成功状态 ✅
- 检查点ID: cp_20260129_153100_step6
- 状态: 步骤6已完成

✅ 自动回滚完成，继续执行步骤7
```

#### 示例2: 步骤6代码审查失败（L2自动回滚）

```markdown
⚠️ @code-reviewer发现Critical问题

问题清单:
1. [Critical] SportRecordServiceImpl.java:45 - 空指针风险
   代码: record.getName().equals("test")
   
2. [Critical] SportRecordController.java:78 - SQL注入风险
   代码: 使用${}拼接SQL

💾 [检查点] 保存失败前状态 ✅
- 检查点ID: cp_before_failure_20260129_153230

🤖 自动回滚机制启动

[1/7] 加载上一个检查点 ✅
- 检查点: cp_20260129_152000_step5 (步骤5完成)

[2/7] 备份当前状态 ✅
- 备份路径: backup/review-failed-20260129-153230/

[3/7] 执行回滚操作 ✅
- 回滚级别: L2（中等）
- 回滚范围: Service层和Controller层

[4/7] 分析失败原因 ✅
根因: 代码生成时未考虑空指针和SQL注入防护
建议: 使用Objects.equals()和参数化查询

[5/7] 调整策略 ✅
修复方案:
- 问题1: 使用Objects.equals(record.getName(), "test")
- 问题2: 修改Mapper XML，使用#{}替代${}

[6/7] 自动修复并重试 ✅
- 修复代码: 应用修复方案
- 重新审查: @code-reviewer
- 审查结果: ✅ 通过（无Critical问题）

[7/7] 记录回滚日志 ✅
- 日志路径: docs/项目状态.md

💾 [检查点] 保存成功状态 ✅
- 检查点ID: cp_20260129_153300_step6

✅ 自动回滚完成，继续执行步骤7
```

#### 示例3: 步骤8测试失败升级为L3（需用户确认）

```markdown
❌ 测试失败（Critical级别）

失败测试: 5/45个
Critical失败: 3个
- testUpdateByBo_NotExists: NullPointerException
- testDeleteByIds_Cascade: ForeignKeyConstraintException  
- testQueryByCondition_Complex: SQLSyntaxErrorException

🤖 自动回滚机制尝试修复

[尝试1/3] 修复testUpdateByBo_NotExists ❌ 失败
[尝试2/3] 修复testDeleteByIds_Cascade ❌ 失败
[尝试3/3] 修复testQueryByCondition_Complex ❌ 失败

⚠️ 自动修复失败，升级为L3级别

🔍 根因分析（@bug-detective）:
问题根源: 数据库表结构设计存在缺陷
- 缺少级联删除配置
- 查询条件字段类型不匹配
- 测试数据初始化不完整

💡 建议回滚方案:

📦 方案A: 返回步骤5重新设计表结构（推荐）
   - 修复表结构设计缺陷
   - 添加级联删除配置
   - 重新生成代码
   - 耗时: 30分钟
   - 成功率: 95%

📦 方案B: 修改现有代码适配（不推荐）
   - 修改Service层逻辑
   - 修改测试数据
   - 耗时: 60分钟
   - 成功率: 60%

⚠️ 此操作需要用户确认（L3级别）

请选择回滚方案 [A/B] 或输入'cancel'取消:
```

---

### 自动回滚配置

可在项目根目录创建 `.rollback-config.yml` 自定义配置：

```yaml
# 自动回滚配置文件
auto_rollback:
  enabled: true  # 是否启用自动回滚
  
  # 支持自动回滚的级别
  levels:
    - L1  # 轻微回滚
    - L2  # 中等回滚
  
  # 最大重试次数
  max_retries:
    L1: 3  # L1级别最多重试3次
    L2: 3  # L2级别最多重试3次
  
  # 备份配置
  backup:
    enabled: true  # 是否自动备份
    path: "backup/"  # 备份路径
    retention_days: 7  # 保留天数
  
  # 检查点配置 🆕
  checkpoint:
    enabled: true  # 是否启用检查点
    path: ".checkpoints/"  # 检查点保存路径
    auto_save: true  # 每步完成后自动保存
    save_triggers:  # 检查点保存时机
      - step_completed  # 步骤完成时
      - before_rollback  # 回滚前
      - manual  # 手动触发
    retention_count: 10  # 保留最近N个检查点
    resume_on_startup: true  # 启动时自动恢复未完成任务
  
  # 日志配置
  logging:
    enabled: true  # 是否记录日志
    path: "docs/项目状态.md"  # 日志路径
    verbose: false  # 是否详细日志
  
  # 通知配置（可选）
  notification:
    enabled: false  # 是否发送通知
    channels:
      - email  # 邮件通知
      - slack  # Slack通知
```

---

## 💾 检查点与断点续传 🆕

### 核心理念

**自动保存进度，支持随时恢复，避免重复工作**

- ✅ **自动检查点**：每个步骤完成后自动保存状态
- ✅ **断点续传**：意外中断后可从上次检查点继续
- ✅ **回滚恢复**：回滚前自动创建检查点，支持恢复到任意稳定状态
- ✅ **智能清理**：自动清理过期检查点，保留最近10个

---

### 检查点保存时机

| 触发时机 | 说明 | 保存内容 | 自动/手动 |
|---------|------|---------|----------|
| **步骤完成** | 每个步骤成功完成后 | 完整状态快照 | 🔄 自动 |
| **回滚前** | 执行回滚操作前 | 回滚前状态 | 🔄 自动 |
| **失败前** | 检测到即将失败时 | 失败前状态 | 🔄 自动 |
| **手动保存** | 用户主动触发 | 当前完整状态 | ⚠️ 手动 |

---

### 检查点内容结构

每个检查点包含以下信息：

```json
{
  "checkpoint_id": "cp_20260129_153045_step6",
  "timestamp": "2026-01-29T15:30:45Z",
  "step_number": 6,
  "step_name": "后端开发",
  "status": "completed",
  "context": {
    "module_name": "sport",
    "module_path": "ruoyi-modules/ruoyi-sport",
    "requirements": {
      "feature": "运动记录管理",
      "entities": ["SportRecord"],
      "operations": ["CRUD", "统计分析"]
    },
    "completed_steps": [1, 2, 3, 4, 5, 6],
    "current_files": [
      "ruoyi-modules/ruoyi-sport/src/main/java/org/dromara/sport/domain/SportRecord.java",
      "ruoyi-modules/ruoyi-sport/src/main/java/org/dromara/sport/service/ISportRecordService.java",
      "ruoyi-modules/ruoyi-sport/src/main/java/org/dromara/sport/controller/SportRecordController.java"
    ],
    "git_commit": "a1b2c3d4",
    "database_version": "V1.0__sport_record.sql"
  },
  "metadata": {
    "token_used": 15000,
    "duration_seconds": 180,
    "retry_count": 0,
    "quality_score": 95
  }
}
```

---

### 断点续传流程

```mermaid
启动开发流程
    ↓
检测到检查点文件? ────────────────────────┐
    ├─ 是 ↓                              │
    │  显示可恢复的检查点列表              │
    │  ├─ 最近检查点: 步骤6 (2分钟前)     │
    │  ├─ 步骤5检查点 (10分钟前)          │
    │  └─ 步骤4检查点 (20分钟前)          │
    │      ↓                              │
    │  询问用户: 是否恢复?                │
    │      ├─ 是 ↓                        │
    │      │  选择检查点                  │
    │      │  ├─ 加载状态                 │
    │      │  ├─ 恢复上下文               │
    │      │  ├─ 验证完整性               │
    │      │  └─ 继续执行                 │
    │      │      ↓                       │
    │      │  从下一步骤继续 ──────────┐  │
    │      │                           │  │
    │      └─ 否 ↓                     │  │
    │         从头开始 ────────────────┼──┘
    │                                 │
    └─ 否 ↓                           │
       从头开始 ──────────────────────┘
           ↓
       正常执行流程
           ↓
       每步完成后自动保存检查点
```

---

### 断点续传示例

#### 示例1: 正常恢复（步骤6中断后继续）

```markdown
🔍 检测到未完成的开发任务

可恢复的检查点:
┌─────────────────────────────────────────────────────┐
│ 检查点 #1 (推荐)                                     │
│ - 时间: 2分钟前 (2026-01-29 15:30:45)               │
│ - 步骤: 步骤6 - 后端开发                             │
│ - 状态: ✅ 已完成                                    │
│ - 模块: sport (运动记录管理)                         │
│ - 进度: 6/11 (55%)                                  │
│ - Token已用: 15,000                                 │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│ 检查点 #2                                            │
│ - 时间: 10分钟前 (2026-01-29 15:22:30)              │
│ - 步骤: 步骤5 - 数据库设计                           │
│ - 状态: ✅ 已完成                                    │
│ - 进度: 5/11 (45%)                                  │
└─────────────────────────────────────────────────────┘

是否从检查点恢复? [1/2/N(从头开始)]: 1

✅ 正在恢复检查点 #1...

[1/5] 加载状态信息 ✅
- 模块: sport
- 已完成步骤: 1-6
- 下一步骤: 步骤7 - 前端开发

[2/5] 恢复上下文 ✅
- 需求文档: ✅ 已加载
- 技术设计: ✅ 已加载
- 数据库表: ✅ 已验证 (sport_record)
- 后端代码: ✅ 已验证 (3个文件)

[3/5] 验证完整性 ✅
- 文件完整性: ✅ 通过
- Git状态: ✅ 正常 (commit: a1b2c3d4)
- 数据库状态: ✅ 正常

[4/5] 恢复环境 ✅
- 工作目录: ✅ 已切换
- 依赖检查: ✅ 通过

[5/5] 准备继续 ✅

✅ 恢复完成！从步骤7继续执行...

📊 恢复统计:
- 节省时间: 约30分钟
- 避免重复: 步骤1-6
- Token节省: 15,000

---

继续执行步骤7: 前端开发...
```

#### 示例2: 回滚到历史检查点

```markdown
❌ 步骤8测试失败，需要回滚

🔍 可用的稳定检查点:

┌─────────────────────────────────────────────────────┐
│ 检查点 #1 - 步骤7完成 (推荐)                         │
│ - 时间: 5分钟前                                      │
│ - 状态: ✅ 前端代码已完成                            │
│ - 质量: 95分                                         │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│ 检查点 #2 - 步骤6完成                                │
│ - 时间: 15分钟前                                     │
│ - 状态: ✅ 后端代码已完成                            │
│ - 质量: 98分                                         │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│ 检查点 #3 - 步骤5完成                                │
│ - 时间: 25分钟前                                     │
│ - 状态: ✅ 数据库设计已完成                          │
│ - 质量: 100分                                        │
└─────────────────────────────────────────────────────┘

💡 建议: 回滚到检查点 #2 (步骤6)，重新生成测试代码

选择回滚目标 [1/2/3]: 2

✅ 正在回滚到检查点 #2...

[1/4] 保存当前状态为临时检查点 ✅
- 临时检查点: cp_temp_20260129_153530

[2/4] 恢复到步骤6完成状态 ✅
- 删除步骤7-8产生的文件
- 恢复Git到commit: a1b2c3d4
- 清理临时数据

[3/4] 验证回滚结果 ✅
- 代码完整性: ✅ 通过
- 编译检查: ✅ 通过
- 数据库状态: ✅ 正常

[4/4] 准备重新执行 ✅

✅ 回滚完成！从步骤7重新开始...

📊 回滚统计:
- 回滚范围: 步骤7-8
- 保留内容: 步骤1-6
- 耗时: 30秒
```

#### 示例3: 手动创建检查点

```markdown
💡 用户请求: "保存当前进度"

✅ 正在创建手动检查点...

[1/3] 收集当前状态 ✅
- 当前步骤: 步骤6 (进行中)
- 完成进度: 50%
- 已生成文件: 5个

[2/3] 保存检查点 ✅
- 检查点ID: cp_manual_20260129_154000
- 保存路径: .checkpoints/cp_manual_20260129_154000.json

[3/3] 验证完整性 ✅

✅ 检查点创建成功！

📋 检查点信息:
- ID: cp_manual_20260129_154000
- 类型: 手动保存
- 步骤: 步骤6 (进行中)
- 大小: 2.5 KB
- 可恢复: ✅ 是

💡 提示: 可随时使用 "恢复检查点" 命令恢复到此状态
```

---

### 检查点管理命令

```bash
# ============= 查看检查点列表 =============
# 列出所有可用检查点
ls -lh .checkpoints/

# 查看检查点详情
cat .checkpoints/cp_20260129_153045_step6.json | jq

# ============= 恢复检查点 =============
# 方式1: 启动时自动提示恢复
# (开发流程启动时自动检测)

# 方式2: 手动恢复到指定检查点
# 在对话中说: "恢复到步骤6的检查点"

# ============= 手动创建检查点 =============
# 在对话中说: "保存当前进度" 或 "创建检查点"

# ============= 清理检查点 =============
# 删除所有检查点
rm -rf .checkpoints/

# 删除指定检查点
rm .checkpoints/cp_20260129_153045_step6.json

# 只保留最近5个检查点
ls -t .checkpoints/*.json | tail -n +6 | xargs rm -f
```

---

### 检查点最佳实践

#### ✅ 推荐做法

1. **启用自动检查点**
   - 每个步骤完成后自动保存
   - 无需手动干预，零心智负担

2. **长时间任务前手动保存**
   - 步骤6、7、8前手动创建检查点
   - 避免长时间工作后失败需重做

3. **实验性修改前保存**
   - 尝试新方案前创建检查点
   - 失败后可快速回滚

4. **定期清理旧检查点**
   - 保留最近10个检查点即可
   - 避免占用过多磁盘空间

#### ❌ 避免做法

1. **不要禁用自动检查点**
   - 自动检查点是容错的关键
   - 几乎无性能开销

2. **不要手动编辑检查点文件**
   - 可能导致状态不一致
   - 通过命令管理检查点

3. **不要在检查点目录下存放其他文件**
   - 保持目录纯净
   - 便于自动清理

---

### 检查点与回滚的关系

| 场景 | 检查点作用 | 回滚作用 | 协同效果 |
|------|-----------|---------|---------|
| **步骤失败** | 保存失败前状态 | 恢复到上一个稳定状态 | 快速恢复，避免重做 |
| **意外中断** | 保存最后进度 | - | 断点续传，继续执行 |
| **实验性修改** | 保存修改前状态 | 失败时恢复 | 安全试错 |
| **长时间任务** | 定期保存进度 | 失败时减少损失 | 降低风险 |

---

### 检查点存储结构

```
.checkpoints/
├── cp_20260129_150000_step1.json    # 步骤1完成检查点
├── cp_20260129_150500_step2.json    # 步骤2完成检查点
├── cp_20260129_151000_step3.json    # 步骤3完成检查点
├── cp_20260129_151500_step4.json    # 步骤4完成检查点
├── cp_20260129_152000_step5.json    # 步骤5完成检查点
├── cp_20260129_153000_step6.json    # 步骤6完成检查点
├── cp_20260129_154000_step7.json    # 步骤7完成检查点
├── cp_manual_20260129_154500.json   # 手动检查点
├── cp_before_rollback_154600.json   # 回滚前检查点
└── latest.json                       # 指向最新检查点的软链接
```

---

## 🗺️ 回滚决策矩阵

### 快速决策表

| 失败步骤 | 问题类型 | 回滚级别 | 回滚目标 | 自动/手动 |
|---------|---------|---------|---------|----------|
| **步骤1** | 需求不明确 | L1 | 重新提问 | 🔄 自动 |
| **步骤2** | 技术方案错误 | L1 | 重新设计 | 🔄 自动 |
| **步骤3** | Git初始化失败 | L1 | 重新初始化 | ⚠️ 手动 |
| **步骤4** | 文档创建失败 | L1 | 删除+重建 | 🔄 自动 |
| **步骤5** | SQL语法错误 | L1 | 修正SQL | 🔄 自动 |
| **步骤5** | 表结构设计错误 | L2 | 回滚到步骤2 | ⚠️ 手动 |
| **步骤5.5** | 生成器配置错误 | L1 | 重新配置 | 🔄 自动 |
| **步骤5.5** | 生成器不可用 | L1 | 切换AI生成 | 🔄 自动 |
| **步骤6** | 代码编译错误 | L1 | 修正代码 | 🔄 自动 |
| **步骤6** | 框架规范错误 | L1 | 修正规范 | 🔄 自动 |
| **步骤6** | 设计方案不支持 | L3 | 回滚到步骤2 | ⚠️ 手动 |
| **步骤7** | 前端编译错误 | L1 | 修正代码 | 🔄 自动 |
| **步骤7** | API路径错误 | L2 | 修正后端+前端 | 🔄 自动 |
| **步骤8** | 单元测试失败(Minor) | L1 | 修正代码 | 🔄 自动 |
| **步骤8** | 单元测试失败(Critical) | L2 | 激活@bug-detective | 🔄 自动 |
| **步骤8** | 测试覆盖率不足 | L1 | 补充测试 | 🔄 自动 |
| **步骤9** | Critical问题 | L2 | 修复+重新审查 | 🔄 自动 |
| **步骤9** | Major问题(>10个) | L2 | 回滚到步骤6 | ⚠️ 手动 |
| **步骤9** | 工具执行失败 | L1 | 切换人工检查 | 🔄 自动 |
| **步骤10** | 文档更新失败 | L1 | 修正格式 | 🔄 自动 |
| **步骤11** | Git合并冲突 | L2 | 解决冲突 | ⚠️ 手动 |
| **步骤11** | 提交被拒绝 | L1 | 重新提交 | 🔄 自动 |

---

## 🔧 分步骤回滚指南

### 步骤1失败：需求澄清

#### 失败场景
```
❌ 场景A: 用户无法提供关键信息
❌ 场景B: 需求自相矛盾
❌ 场景C: 需求超出框架能力
```

#### 回滚决策树
```mermaid
需求澄清失败
    ↓
用户无法提供关键信息?
    ├─ 是 → 暂停流程，记录待澄清项 → 等待用户补充信息
    └─ 否 ↓
需求自相矛盾?
    ├─ 是 → 激活@requirements-analyst → 列出冲突点 → 引导用户解决
    └─ 否 ↓
需求超出框架能力?
    ├─ 是 → 提示用户调整需求 → 或选择其他技术方案
    └─ 否 → 继续澄清
```

#### 处理流程
```markdown
🔍 需求澄清失败处理

1. 自动分析失败原因
   AI执行：
   - 检查哪些必填项未获得答案
   - 识别矛盾的需求描述
   - 评估框架能力边界

2. 生成待澄清清单
   输出：
   📋 待澄清问题清单（优先级排序）
   1. [高优先级] XXX（影响：阻塞后续设计）
   2. [中优先级] XXX（影响：可能影响表结构）
   3. [低优先级] XXX（影响：仅影响前端展示）

3. 用户确认
   选项：
   - [暂停] 暂停流程，等待用户补充信息
   - [跳过] 跳过低优先级问题，继续流程（AI假设默认值）
   - [重新提问] 重新提问（换一种方式）

4. 记录到文档
   docs/项目状态.md:
   ## ⚠️ 待澄清问题
   - [列出待澄清的问题]
   - [记录暂停原因]
```

#### 回滚操作
```bash
# 无需回滚代码，仅需：
# 1. 记录待澄清问题
echo "## ⚠️ 待澄清问题 ($(date))" >> docs/项目状态.md
echo "- [列出问题]" >> docs/项目状态.md

# 2. 暂停流程标记
echo "状态: 暂停 - 等待需求补充" >> docs/项目状态.md
```

---

### 步骤2失败：技术设计

#### 失败场景
```
❌ 场景A: 表结构设计不合理（缺少必要字段）
❌ 场景B: 模块归属选择错误
❌ 场景C: API设计与需求不匹配
```

#### 回滚决策树
```
技术设计失败
    ↓
已进行到哪个步骤?
    ├─ 仅步骤2 → L1回滚（修改设计文档） → 无需删除代码
    ├─ 步骤5已执行 → L2回滚（删除SQL脚本+表） → 重新设计
    ├─ 步骤6已执行 → L3回滚（删除代码+SQL） → 重新设计
    └─ 步骤7+已执行 → L3回滚（删除所有代码） → 重新设计
```

#### 处理流程
```markdown
🔄 技术设计失败回滚

阶段1: 评估影响范围
AI自动检查：
- [ ] 步骤5(SQL)是否已执行? 
- [ ] 步骤6(后端)是否已生成?
- [ ] 步骤7(前端)是否已生成?
- [ ] Git是否已有提交?

阶段2: 用户确认回滚方案
输出：
⚠️ 检测到技术设计问题：[问题描述]

影响范围：
- [列出已完成的步骤和生成的文件]

回滚方案：
📦 方案A: 最小回滚（推荐）
   - 仅修改设计文档
   - 适用于：设计问题不影响已生成代码
   - 风险：低

📦 方案B: 部分回滚
   - 删除SQL脚本 + 回滚数据库
   - 保留代码框架，手动调整
   - 适用于：仅表结构需调整
   - 风险：中

📦 方案C: 完全回滚（彻底）
   - 删除所有生成的代码和SQL
   - 从步骤2重新开始
   - 适用于：设计根本性错误
   - 风险：高（丢失已完成工作）

请选择回滚方案 [A/B/C]:

阶段3: 执行回滚
[根据用户选择执行对应操作]

阶段4: 记录回滚原因
docs/项目状态.md:
## 🔄 回滚记录
- 时间: [时间]
- 原因: [设计问题描述]
- 回滚方案: [A/B/C]
- 影响范围: [列出删除的文件]
- 教训: [避免类似问题的建议]
```

#### 回滚操作
```bash
# 方案A: 最小回滚（仅修改文档）
# 无需删除文件

# 方案B: 部分回滚（删除SQL）
# 1. 回滚数据库
mysql -u root -p -e "DROP TABLE IF EXISTS [表名];"

# 2. 删除SQL文件
rm -rf sql/[模块名]/

# 3. Git回滚（如已提交）
git reset --soft HEAD~1  # 保留代码修改
# 或
git reset --hard HEAD~1  # 丢弃代码修改

# 方案C: 完全回滚（删除所有代码）
# 1. 回滚数据库
mysql -u root -p -e "DROP TABLE IF EXISTS [表名];"

# 2. 删除后端代码
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/domain/[Entity]*
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/mapper/[Entity]*
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/service/
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/resources/mapper/[模块]/

# 3. 删除前端代码
rm -rf plus-ui/src/api/[模块]/
rm -rf plus-ui/src/views/[模块]/

# 4. 删除SQL文件
rm -rf sql/[模块名]/

# 5. Git回滚
git reset --hard HEAD~[提交数]
# 或重置整个功能分支
git checkout main
git branch -D feature/[功能名]
git checkout -b feature/[功能名]
```

---

### 步骤5失败：数据库设计

#### 失败场景
```
❌ 场景A: SQL语法错误
❌ 场景B: 字段类型不匹配
❌ 场景C: 索引创建失败
❌ 场景D: 外键约束冲突
```

#### 回滚决策树
```
SQL执行失败
    ↓
SQL语法错误?
    ├─ 是 → 修正语法 → 重新执行 → 成功? → 继续流程
    │                              └─ 失败 → 检查数据库权限
    └─ 否 ↓
字段类型不合理?
    ├─ 是 → 回滚到步骤2（修改设计） → 重新生成SQL → 重新执行
    └─ 否 ↓
表已存在?
    ├─ 是 → 询问：[覆盖/重命名/取消]
    │       ├─ 覆盖 → DROP TABLE → 重新执行
    │       ├─ 重命名 → 修改表名 → 重新执行
    │       └─ 取消 → 终止流程
    └─ 否 → 检查数据库连接
```

#### 处理流程
```markdown
🔧 SQL执行失败处理

阶段1: 错误诊断
AI自动分析：
- 解析MySQL错误信息
- 识别错误类型（语法/权限/冲突）
- 提供修复建议

阶段2: 自动修复（适用于简单错误）
自动修复场景：
✅ 语法错误: 自动修正 → 重新执行
✅ 表已存在: 询问后自动覆盖
✅ 字段名冲突: 自动重命名 → 重新执行

阶段3: 手动修复（复杂错误）
需用户介入：
⚠️ 字段类型不合理 → 返回步骤2重新设计
⚠️ 外键约束冲突 → 检查关联表 → 调整设计
⚠️ 数据库权限不足 → 提示用户授权

阶段4: 验证修复
自动验证：
- 重新执行SQL
- 检查表是否创建成功
- 验证字段和索引
```

#### 回滚操作
```bash
# 场景A: SQL语法错误（修正后重新执行）
# 无需回滚，直接修正SQL文件

# 场景B: 表已存在（覆盖）
# 1. 删除现有表
mysql -u root -p << EOF
DROP TABLE IF EXISTS [表名];
EOF

# 2. 重新执行SQL
mysql -u root -p < sql/[模块名]/[表名].sql

# 场景C: 字段类型错误（需回滚到步骤2）
# 1. 删除已创建的表
mysql -u root -p -e "DROP TABLE IF EXISTS [表名];"

# 2. 删除SQL文件
rm sql/[模块名]/[表名].sql

# 3. 标记需要重新设计
echo "⚠️ 需要返回步骤2重新设计表结构" >> docs/项目状态.md
```

---

### 步骤5.5失败：代码生成方式选择

#### 失败场景
```
❌ 场景A: 代码生成器配置超时（等待>5分钟）
❌ 场景B: 代码生成器生成失败
❌ 场景C: 生成结果与设计不符
```

#### 回滚决策树
```
代码生成方式选择失败
    ↓
超时?
    ├─ 是 → 询问用户：[继续等待/改用AI生成/配置帮助]
    │       ├─ 继续等待 → 延长等待时间
    │       ├─ 改用AI生成 → 切换到方式B → 步骤6
    │       └─ 配置帮助 → 提供详细配置指南
    └─ 否 ↓
生成失败?
    ├─ 是 → 检查失败原因
    │       ├─ 配置错误 → 提供修正建议 → 重新生成
    │       ├─ 工具Bug → 切换到方式B(AI生成)
    │       └─ 表不存在 → 返回步骤5（检查SQL）
    └─ 否 ↓
生成结果不符?
    ├─ 微调可解决 → 记录微调内容 → 继续流程
    └─ 重大差异 → 重新配置 或 切换AI生成
```

#### 处理流程
```markdown
⏰ 代码生成超时处理

阶段1: 超时检测（5分钟）
自动提示：
⏰ 已等待5分钟，代码生成进度如何？

选项：
1. [继续等待] 我还在配置中（延长3分钟）
2. [已生成] 代码已生成，继续流程
3. [改用AI] 切换到AI生成（方式B）
4. [遇到问题] 说明具体问题，获取帮助

阶段2: 延长等待（选项1）
- 延长等待时间至8分钟
- 8分钟后再次询问
- 最多延长2次（总计11分钟）

阶段3: 配置帮助（选项4）
AI提供：
- 配置步骤截图（文字描述）
- 常见配置错误解决方案
- 若依代码生成器视频教程链接

阶段4: 切换AI生成（选项3）
自动执行：
- 切换到方式B
- 跳过步骤5.5
- 直接进入步骤6（AI生成代码）
```

#### 回滚操作
```bash
# 场景A: 超时切换AI生成
# 无需回滚，直接切换生成方式
# 流程: 步骤5.5(方式A超时) → 步骤5.5(方式B) → 步骤6

# 场景B: 生成失败
# 如已生成部分文件，需清理
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/domain/[Entity]*
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/mapper/[Entity]*
# 然后切换到方式B

# 场景C: 生成结果不符（重新生成）
# 1. 备份已生成代码（如需参考）
mkdir -p backup/$(date +%Y%m%d_%H%M%S)
cp -r ruoyi-modules/ruoyi-[模块] backup/$(date +%Y%m%d_%H%M%S)/

# 2. 删除错误代码
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/*

# 3. 重新生成或切换AI生成
```

---

### 步骤6失败：后端开发

#### 失败场景
```
❌ 场景A: 代码编译错误
❌ 场景B: 依赖缺失
❌ 场景C: 框架规范不符
❌ 场景D: @code-reviewer审查失败
```

#### 回滚决策树
```
后端代码生成失败
    ↓
编译错误?
    ├─ 是 → 分析错误类型
    │       ├─ 依赖缺失 → 添加依赖 → 重新编译
    │       ├─ 语法错误 → 自动修正 → 重新编译
    │       └─ 类型不匹配 → 检查步骤5设计 → 修正
    └─ 否 ↓
@code-reviewer发现Critical问题?
    ├─ 是 → 尝试自动修复
    │       ├─ 修复成功 → 重新审查 → 继续
    │       ├─ 修复失败(3次) → 询问用户：
    │       │   ├─ 手动修复 → 暂停流程
    │       │   ├─ 降低标准 → 标记为Major继续
    │       │   └─ 重新生成 → 返回步骤6开始
    │       └─ 根本性问题 → 返回步骤2重新设计
    └─ 否 → 继续流程
```

#### 处理流程
```markdown
🔧 后端代码失败处理

场景1: 编译错误
自动诊断：
- 解析javac错误信息
- 识别错误类型
- 提供修复建议

自动修复（适用于简单错误）：
✅ Import缺失 → 自动添加import
✅ 方法签名不匹配 → 自动调整
✅ 变量未初始化 → 添加默认值

手动修复（复杂错误）：
⚠️ 依赖冲突 → 分析pom.xml → 调整版本
⚠️ 泛型错误 → 提示修改建议
⚠️ 逻辑错误 → 返回步骤2检查设计

场景2: @code-reviewer审查失败
自动修复流程：
1. @code-generator生成代码
2. @code-reviewer审查（发现Critical问题）
3. @code-generator自动修复
4. @code-reviewer重新审查
5. 重复步骤3-4，最多3次
6. 如仍有Critical问题 → 用户介入

循环退出机制：
修复次数: 1/3 → 继续自动修复
修复次数: 2/3 → 继续自动修复
修复次数: 3/3 → 用户介入决策

用户介入选项：
📋 选项A: 继续修复（手动）
   - 暂停流程
   - 提供详细问题清单
   - 等待用户修复后继续

📋 选项B: 降低标准（仅限特殊情况）
   - 将Critical问题降级为Major
   - 记录到待办清单
   - 继续流程（风险较高）

📋 选项C: 重新生成
   - 删除当前代码
   - 返回步骤6开始
   - 调整生成策略

📋 选项D: 重新设计
   - 删除当前代码
   - 返回步骤2
   - 设计方案可能有问题

场景3: 协作智能体超时
超时处理：
- 单次调用超时: 30秒
- 重试3次（指数退避: 1s, 2s, 4s）
- 仍超时 → 降级到人工审查

降级流程：
⚠️ @code-reviewer调用超时
→ 切换到人工审查清单
→ 提示用户手动审查代码
→ 提供审查要点清单
```

#### 回滚操作
```bash
# 场景A: 编译错误（修正后无需回滚）
# 直接修正代码文件

# 场景B: 审查失败（重新生成）
# 1. 备份当前代码（如需参考）
mkdir -p backup/code-gen-failed-$(date +%Y%m%d_%H%M%S)
cp -r ruoyi-modules/ruoyi-[模块] backup/code-gen-failed-$(date +%Y%m%d_%H%M%S)/

# 2. 删除错误代码
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/domain/[Entity]*
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/mapper/[Entity]*
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/service/
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/resources/mapper/[模块]/

# 3. 重新执行步骤6

# 场景C: 根本性问题（返回步骤2）
# 1. 完全清理（执行场景B的删除操作）
# 2. 删除SQL文件
rm -rf sql/[模块名]/
# 3. 回滚数据库
mysql -u root -p -e "DROP TABLE IF EXISTS [表名];"
# 4. 标记返回步骤2
echo "⚠️ 需要返回步骤2重新设计" >> docs/项目状态.md
```

---

### 步骤8失败：测试验证

#### 失败场景
```
❌ 场景A: 单元测试失败（Minor问题）
❌ 场景B: 单元测试失败（Critical问题）
❌ 场景C: 测试覆盖率不达标
❌ 场景D: 测试执行超时
```

#### 回滚决策树
```
测试失败
    ↓
Critical问题?
    ├─ 是 → 激活@bug-detective
    │       ├─ 根因分析完成
    │       ├─ 提供修复方案
    │       ├─ 用户选择：[自动修复/手动修复/重新生成]
    │       └─ 修复后重新测试
    └─ 否 ↓
Minor问题?
    ├─ 是 → 尝试自动修复
    │       ├─ 修复成功 → 重新测试 → 继续
    │       └─ 修复失败 → 记录到待办 → 继续流程
    └─ 否 ↓
覆盖率不达标?
    ├─ 是 → 分析未覆盖代码
    │       ├─ 关键业务方法未覆盖 → 必须补充测试
    │       └─ 非关键代码未覆盖 → 记录待办 → 可继续
    └─ 否 → 测试通过
```

#### 处理流程
```markdown
🧪 测试失败处理

场景1: Minor问题
自动修复流程：
1. @test-engineer识别失败原因
2. 提供修复建议
3. 用户确认后自动修复
4. 重新运行测试
5. 验证修复结果

场景2: Critical问题
深度分析流程：
1. @test-engineer标记为Critical
2. 自动激活@bug-detective
3. @bug-detective执行：
   - 5个为什么根因分析
   - 调用栈分析
   - 相关代码检查
   - 生成修复方案（3个备选）
4. 用户选择修复方案
5. 执行修复
6. 重新测试（完整测试套件）

@bug-detective分析输出：
🔍 Bug定位报告

失败测试: testUpdateByBo_NotExists
错误信息: NullPointerException at line 45

根因分析（5个为什么）：
1. 为什么抛出空指针? → bo为null
2. 为什么bo为null? → 测试数据未正确初始化
3. 为什么数据未初始化? → @Before方法缺失
4. 为什么缺失? → 测试模板生成时遗漏
5. 为什么遗漏? → 测试数据生成器未考虑前置条件

修复方案（按推荐度排序）：
⭐⭐⭐ 方案A: 补充@Before方法（推荐）
   - 耗时: 2分钟
   - 风险: 低
   - 影响: 修复当前问题

⭐⭐ 方案B: 修改测试方法（备选）
   - 耗时: 5分钟
   - 风险: 中
   - 影响: 重构测试结构

⭐ 方案C: 重新生成测试（不推荐）
   - 耗时: 10分钟
   - 风险: 高
   - 影响: 丢失已有测试

请选择修复方案 [A/B/C]:

场景3: 覆盖率不达标
分析与补充：
1. 识别未覆盖的代码
2. 评估是否为关键代码
3. 生成补充测试用例
4. 重新运行测试
5. 验证覆盖率提升

关键代码判定：
✅ 关键: 支付、权限、核心算法
⚠️ 重要: CRUD业务逻辑
💡 一般: Getter/Setter、工具方法

场景4: 测试超时
超时处理：
1. 识别超时测试用例
2. 分析是否为性能问题
3. 提供优化建议：
   - 减少测试数据量
   - 使用@Transactional回滚
   - 模拟外部依赖
```

#### 回滚操作
```bash
# 场景A: Minor问题（修复测试代码）
# 无需回滚业务代码，仅修改测试文件

# 场景B: Critical问题（修复业务代码）
# 1. 修正业务代码
# 编辑相关Service/Controller文件

# 2. 重新运行测试
mvn clean test

# 3. 验证修复
mvn jacoco:report

# 场景C: 根本性问题（返回步骤6重新生成）
# 1. 备份当前代码
mkdir -p backup/test-failed-$(date +%Y%m%d_%H%M%S)
cp -r ruoyi-modules/ruoyi-[模块] backup/test-failed-$(date +%Y%m%d_%H%M%S)/

# 2. 删除业务代码
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/*

# 3. 保留测试代码（作为参考）
# 测试代码可以帮助重新生成时验证

# 4. 返回步骤6重新生成
```

---

### 步骤9失败：代码质量检查

#### 失败场景
```
❌ 场景A: Critical问题（必须修复）
❌ 场景B: Major问题过多（>10个）
❌ 场景C: 安全漏洞（高危）
❌ 场景D: 质量工具执行失败
```

#### 回滚决策树
```
质量检查失败
    ↓
Critical问题?
    ├─ 是 → 自动激活@bug-detective
    │       ├─ 分析根因
    │       ├─ 提供修复方案
    │       ├─ 自动修复
    │       └─ 重新检查 → 通过? → 继续
    │                             └─ 失败 → 用户介入
    └─ 否 ↓
高危安全漏洞?
    ├─ 是 → 风险评估
    │       ├─ 真实威胁 → 必须修复
    │       └─ 误报/不影响 → 记录评估 → 可继续
    └─ 否 ↓
Major问题>10个?
    ├─ 是 → 代码质量太差
    │       ├─ 返回步骤6重新生成（推荐）
    │       └─ 批量修复（耗时长）
    └─ 否 → 记录待办 → 继续流程
```

#### 处理流程
```markdown
🔍 质量检查失败处理

场景1: Critical问题
自动修复流程：
1. @quality-inspector发现Critical问题
2. 自动激活@bug-detective深度分析
3. @bug-detective提供修复方案
4. 自动应用修复（或用户确认）
5. 重新执行质量检查
6. 验证修复结果

Critical问题示例：
🔴 空指针异常风险
🔴 SQL注入漏洞
🔴 死循环
🔴 资源未关闭
🔴 并发安全问题

自动修复示例：
问题: SportRecordServiceImpl.java:45 空指针风险
代码: record.getName().equals("test")
修复: Objects.equals(record.getName(), "test")
状态: ✅ 自动修复完成

场景2: 高危安全漏洞
风险评估流程：
1. @quality-inspector检测到高危漏洞
2. 自动评估影响范围
3. 生成风险评估报告
4. 提供处理建议

风险评估报告示例：
⚠️ 高危漏洞: CVE-2021-29425
依赖: commons-io:2.6
CVSS评分: 7.5 (高危)

影响分析：
- 项目使用: FileUtils.readFileToString()
- 漏洞场景: 文件路径遍历攻击
- 实际风险: ✅ 低（项目仅读取固定路径文件）

处理建议：
✅ [推荐] 记录评估结果，后续升级（优先级P3）
⚠️ [备选] 立即升级到2.11.0（可能引入兼容性问题）
❌ [不推荐] 替换依赖（影响范围大）

请选择处理方式 [1/2/3]:

场景3: Major问题过多
批量修复决策：
问题数量: 15个Major问题

评估：
⚠️ 代码质量较差，建议重新生成

选项：
📦 选项A: 返回步骤6重新生成（推荐）
   - 优点: 代码质量更高
   - 缺点: 需重新生成
   - 耗时: 15分钟

📦 选项B: 批量修复（备选）
   - 优点: 保留当前代码
   - 缺点: 修复耗时长
   - 耗时: 30-45分钟

📦 选项C: 部分修复（妥协）
   - 修复前5个最严重问题
   - 其他记录待办
   - 耗时: 10分钟

请选择 [A/B/C]:

场景4: 工具执行失败
降级策略：
1. 检测工具执行失败
2. 尝试修复配置（自动）
3. 仍失败 → 切换人工检查清单
4. 提供人工检查清单
5. 用户逐项检查
6. 记录检查结果

人工检查清单（精简版）：
📋 代码规范（必选）
- [ ] JavaDoc注释完整
- [ ] 命名规范正确
- [ ] 无魔法数字/字符串

📋 安全检查（必选）
- [ ] 使用参数化查询（#{}）
- [ ] 用户输入已校验
- [ ] 敏感信息已脱敏

📋 性能检查（可选）
- [ ] 无循环查询数据库
- [ ] 大数据量使用分页

完成检查后继续流程。
```

#### 回滚操作
```bash
# 场景A: Critical问题（修复后无需回滚）
# 自动修复或手动修复代码

# 场景B: Major问题过多（返回步骤6重新生成）
# 1. 备份当前代码
mkdir -p backup/quality-failed-$(date +%Y%m%d_%H%M%S)
cp -r ruoyi-modules/ruoyi-[模块] backup/quality-failed-$(date +%Y%m%d_%H%M%S)/

# 2. 删除业务代码
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/domain/
rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/service/

# 3. 保留测试代码和Mapper
# 这些可以在重新生成后复用

# 4. 返回步骤6，调整生成策略
echo "⚠️ 返回步骤6，需改进代码生成质量" >> docs/项目状态.md

# 场景C: 工具执行失败（切换人工检查）
# 无需回滚代码
# 使用人工检查清单完成质量验证
```

---

### 步骤11失败：Git提交

#### 失败场景
```
❌ 场景A: 合并冲突
❌ 场景B: 提交被pre-commit钩子拒绝
❌ 场景C: 推送到远程失败
❌ 场景D: 敏感信息检测到
```

#### 回滚决策树
```
Git提交失败
    ↓
合并冲突?
    ├─ 是 → 分析冲突类型
    │       ├─ 文件冲突 → 解决冲突 → 重新提交
    │       ├─ 大范围冲突 → 建议拉取最新代码 → 重新开发
    │       └─ 无法自动合并 → 手动介入
    └─ 否 ↓
pre-commit钩子拒绝?
    ├─ 是 → 检查拒绝原因
    │       ├─ 代码格式 → 自动格式化 → 重新提交
    │       ├─ 测试失败 → 返回步骤8修复
    │       └─ 其他规则 → 修复后重新提交
    └─ 否 ↓
包含敏感信息?
    ├─ 是 → 移除敏感信息
    │       ├─ 文件级 → 从提交中移除文件
    │       ├─ 行级 → 移除敏感行
    │       └─ 已推送 → 警告+撤销提交
    └─ 否 ↓
推送失败?
    ├─ 权限不足 → 检查Git配置
    ├─ 网络问题 → 重试推送
    └─ 分支保护 → 创建PR而非直接推送
```

#### 处理流程
```markdown
📦 Git提交失败处理

场景1: 合并冲突
冲突解决流程：
1. 拉取最新代码
   git fetch origin
   git diff origin/main...HEAD

2. 分析冲突范围
   AI自动分析：
   - 冲突文件数量
   - 冲突代码行数
   - 冲突类型（内容/删除/重命名）

3. 提供解决方案
   冲突类型判定：
   
   ✅ 轻微冲突（<5个文件，<50行）
   → 自动解决 + 用户确认
   
   ⚠️ 中等冲突（5-20个文件）
   → 提供解决建议 + 用户手动解决
   
   🔴 严重冲突（>20个文件或核心文件）
   → 建议放弃当前分支 + 重新开发

4. 执行解决
   git merge origin/main
   # 解决冲突
   git add .
   git commit -m "merge: 解决合并冲突"

场景2: pre-commit钩子拒绝
钩子失败处理：
1. 识别钩子类型
   - lint-staged（代码格式）
   - ESLint/Prettier（JS/TS）
   - CheckStyle（Java）
   - 自定义测试钩子

2. 自动修复（适用于格式问题）
   # Java格式化
   mvn spotless:apply
   
   # 前端格式化
   npm run lint:fix
   
   # 重新提交
   git add .
   git commit -m "[原提交信息]"

3. 手动修复（测试失败等）
   → 返回对应步骤修复
   → 测试通过后重新提交

场景3: 敏感信息检测
敏感信息处理：
1. AI自动检测
   检测内容：
   - .env, .env.*
   - *.key, *.pem
   - password=xxx
   - api_key=xxx
   - jdbc:mysql://xxx

2. 移除敏感信息
   未推送：
   git reset HEAD [敏感文件]
   # 或
   git restore --staged [敏感文件]
   
   已推送（严重）：
   ⚠️ 警告：敏感信息已推送到远程！
   
   紧急处理：
   1. 立即撤销提交
      git reset --hard HEAD~1
      git push origin +feature/[分支名]
   
   2. 更换泄露的密钥
      [提示用户更换密码/密钥]
   
   3. 重新提交（移除敏感信息）

场景4: 推送失败
推送失败处理：
1. 权限不足
   → 检查SSH密钥配置
   → 检查仓库访问权限

2. 分支保护
   → 改为创建PR
   gh pr create --title "..." --body "..."

3. 网络问题
   → 重试3次
   → 提示用户检查网络
```

#### 回滚操作
```bash
# 场景A: 合并冲突（回滚到冲突前）
# 1. 取消合并
git merge --abort

# 2. 回到冲突前状态
git checkout feature/[分支名]

# 3. 重新策略合并
git pull origin main --rebase

# 场景B: pre-commit失败（回滚提交）
# 1. 回滚最后一次提交（保留修改）
git reset --soft HEAD~1

# 2. 修复问题后重新提交

# 场景C: 敏感信息已提交未推送（修改提交）
# 1. 从暂存区移除
git restore --staged [敏感文件]

# 2. 添加到.gitignore
echo "[敏感文件]" >> .gitignore

# 3. 修改最后一次提交
git add .gitignore
git commit --amend --no-edit

# 场景D: 敏感信息已推送（强制回滚）
# ⚠️ 危险操作，需用户明确确认！

# 1. 回滚提交
git reset --hard HEAD~1

# 2. 强制推送（覆盖远程）
git push origin +feature/[分支名]

# 3. 通知团队成员
echo "⚠️ 已强制回滚[分支名]，团队成员需重新拉取" >> docs/项目状态.md
```

---

## 🤖 智能体异常处理

### 智能体调用失败

#### 超时机制
```yaml
配置：
  单次调用超时: 30秒
  重试次数: 3次
  重试间隔: 指数退避(1s, 2s, 4s)

处理流程：
  1. 第1次超时 → 等待1秒 → 重试
  2. 第2次超时 → 等待2秒 → 重试
  3. 第3次超时 → 等待4秒 → 重试
  4. 仍超时 → 降级处理
```

#### 降级策略
```markdown
智能体调用失败降级（阶段1-4，10个智能体）

【阶段1：基础智能体】
@requirements-analyst 超时:
→ 降级：使用简化提问流程
→ 影响：可能遗漏部分需求细节

@code-generator 超时:
→ 降级：使用基础代码模板生成
→ 影响：代码可能需要更多手动调整

@test-engineer 超时:
→ 降级：生成基础测试框架
→ 影响：测试覆盖率可能不足

【阶段2：质量保障智能体】
@code-reviewer 超时:
→ 降级：使用人工审查清单
→ 影响：审查深度降低

@quality-inspector 超时:
→ 降级：使用人工检查清单
→ 影响：质量检查不全面

@bug-detective 超时:
→ 降级：提供基础调试建议
→ 影响：根因分析深度降低

@project-manager 超时:
→ 降级：基于Git日志生成报告
→ 影响：报告详细度降低

【阶段4：发布交付智能体】
@git-workflow-manager 超时:
→ 降级：提供基础Git命令提示
→ 影响：需要手动执行Git操作

@release-manager 超时:
→ 降级：提供CHANGELOG模板
→ 影响：需要手动编写发布说明

@deployment-assistant 超时:
→ 降级：提供基础部署脚本模板
→ 影响：需要手动配置部署参数
```

### 智能体协作失败

#### 场景：@code-generator → @code-reviewer失败
```markdown
问题：步骤6代码生成后，自动触发@code-reviewer审查失败

诊断：
1. 检查@code-reviewer是否可用
2. 检查生成的代码是否完整
3. 检查审查工具依赖

处理：
情况A: @code-reviewer临时不可用
→ 降级到人工审查清单
→ 标记需要后续审查

情况B: 代码格式异常导致审查失败
→ 自动格式化代码
→ 重新触发审查

情况C: 审查工具依赖缺失
→ 切换到基础规范检查
→ 记录问题，提示安装依赖
```

#### 场景：步骤8 → 步骤9数据传递失败
```markdown
问题：测试覆盖率报告未成功传递给@quality-inspector

诊断：
1. 检查JaCoCo报告是否生成
2. 检查报告路径是否正确
3. 检查文件读取权限

处理：
情况A: 报告未生成
→ 重新执行测试生成报告
→ 验证生成成功后传递

情况B: 报告路径错误
→ 自动检测报告位置
→ 更新路径配置

情况C: 数据传递机制失败
→ 降级：@quality-inspector独立执行mvn jacoco:report
→ 读取最新报告
```

---

## 💻 回滚执行命令

### Git回滚命令
```bash
# ============= 回滚未提交的修改 =============
# 1. 回滚单个文件
git checkout -- <文件路径>

# 2. 回滚所有修改
git checkout -- .

# 3. 删除未跟踪的文件
git clean -fd

# 4. 删除未跟踪的文件（包括.gitignore文件）
git clean -fdx

# ============= 回滚已提交未推送 =============
# 1. 回滚最后一次提交（保留修改）
git reset --soft HEAD~1

# 2. 回滚最后一次提交（丢弃修改）
git reset --hard HEAD~1

# 3. 回滚最近N次提交（保留修改）
git reset --soft HEAD~N

# 4. 回滚到指定提交（保留修改）
git reset --soft <commit-hash>

# ============= 回滚已推送的提交 =============
# ⚠️ 危险操作，需团队协调

# 1. 回滚并保留历史（推荐）
git revert HEAD
git push origin <branch>

# 2. 强制回滚（不推荐，会改写历史）
git reset --hard HEAD~1
git push origin +<branch>  # 强制推送

# ============= 分支管理 =============
# 1. 切换回主分支
git checkout main

# 2. 删除本地分支
git branch -d <branch>   # 已合并分支
git branch -D <branch>   # 强制删除

# 3. 删除远程分支
git push origin --delete <branch>

# 4. 重建功能分支
git checkout main
git pull
git checkout -b feature/<new-name>
```

### 数据库回滚命令
```sql
-- ============= 删除表 =============
-- 1. 删除单个表
DROP TABLE IF EXISTS <表名>;

-- 2. 删除多个表
DROP TABLE IF EXISTS <表1>, <表2>, <表3>;

-- 3. 删除表并级联删除视图
DROP TABLE IF EXISTS <表名> CASCADE;

-- ============= 清空表数据 =============
-- 1. 清空表（保留结构）
TRUNCATE TABLE <表名>;

-- 2. 删除表数据（保留结构）
DELETE FROM <表名>;

-- 3. 重置自增ID
ALTER TABLE <表名> AUTO_INCREMENT = 1;

-- ============= 回滚数据（需事务支持） =============
-- 1. 开启事务
START TRANSACTION;

-- 2. 执行操作
INSERT/UPDATE/DELETE ...

-- 3. 回滚事务
ROLLBACK;

-- ============= 备份与恢复 =============
-- 1. 备份单个表
mysqldump -u root -p 数据库名 表名 > backup.sql

-- 2. 恢复表
mysql -u root -p 数据库名 < backup.sql
```

### 文件回滚命令
```bash
# ============= 备份文件 =============
# 1. 备份单个目录
mkdir -p backup/$(date +%Y%m%d_%H%M%S)
cp -r <目录> backup/$(date +%Y%m%d_%H%M%S)/

# 2. 压缩备份
tar -czf backup/$(date +%Y%m%d_%H%M%S).tar.gz <目录>

# ============= 删除文件 =============
# 1. 删除目录（安全，需确认）
rm -ri <目录>

# 2. 删除目录（强制）
rm -rf <目录>

# 3. 删除特定类型文件
find <目录> -name "*.java" -delete

# ============= 恢复文件 =============
# 1. 从备份恢复
cp -r backup/<时间戳>/<目录> <目标路径>

# 2. 从压缩备份恢复
tar -xzf backup/<时间戳>.tar.gz -C <目标路径>
```

---

## 🎯 常见场景处理

### 场景1: "代码生成后发现表结构设计错误"
```markdown
问题: 步骤6代码已生成，但发现步骤5的表结构有误

解决流程:
1. 评估影响
   AI分析: 表结构错误影响代码生成的哪些部分

2. 回滚决策
   选项A: 轻微错误（字段类型/长度）
   → 修改代码适配新表结构
   → 重新执行步骤5(修改SQL)
   
   选项B: 中等错误（缺少关键字段）
   → 返回步骤2重新设计
   → 删除步骤5-6的产物
   → 从步骤2重新开始
   
   选项C: 重大错误（表关系错误）
   → 完全回滚到步骤1
   → 重新澄清需求

3. 执行回滚（选项B示例）
   # 删除代码
   rm -rf ruoyi-modules/ruoyi-[模块]/*
   
   # 删除SQL
   rm sql/[模块]/*.sql
   
   # 回滚数据库
   mysql -u root -p -e "DROP TABLE IF EXISTS [表名];"
   
   # 更新文档
   echo "⚠️ 回滚原因：表结构设计错误" >> docs/项目状态.md
   
   # Git回滚
   git reset --hard HEAD~[提交数]

4. 重新执行
   从步骤2开始 → 重新设计 → 步骤5 → 步骤6
```

### 场景2: "测试失败，多次修复仍无法通过"
```markdown
问题: 步骤8测试失败，经过3次修复仍有5个测试失败

解决流程:
1. 失败分析
   @bug-detective深度分析:
   - 识别5个失败测试的共同根因
   - 评估是否为设计问题还是实现问题

2. 根因判定
   情况A: 测试用例编写错误
   → 修正测试用例
   → 重新运行测试
   
   情况B: 业务逻辑实现错误
   → 返回步骤6修复代码
   → 重新运行测试
   
   情况C: 设计方案不支持需求
   → 返回步骤2重新设计
   → 完全回滚

3. 用户决策
   AI提示:
   ⚠️ 经过3次修复，仍有5个测试失败
   
   根因分析：业务逻辑实现与需求不符
   
   建议：
   📦 选项A: 返回步骤6，重新生成Service层（推荐）
      耗时: 15分钟
      成功率: 90%
   
   📦 选项B: 继续手动修复（不推荐）
      耗时: 未知（可能>1小时）
      成功率: 60%
   
   📦 选项C: 降低测试标准（风险高）
      跳过失败测试，标记为待修复
      成功率: 100%（但质量下降）
   
   请选择 [A/B/C]:

4. 执行回滚（选项A）
   # 备份当前代码
   mkdir -p backup/test-failed-$(date +%Y%m%d_%H%M%S)
   cp -r ruoyi-modules/ruoyi-[模块] backup/$(date +%Y%m%d_%H%M%S)/
   
   # 删除Service层
   rm -rf ruoyi-modules/ruoyi-[模块]/src/main/java/org/dromara/[模块]/service/
   
   # 保留测试（用于验证）
   # 返回步骤6重新生成
```

### 场景3: "质量检查发现大量问题"
```markdown
问题: 步骤9质量检查发现3个Critical + 15个Major问题

解决流程:
1. 问题分类
   @quality-inspector分析:
   
   Critical问题（必须修复）:
   - 空指针风险 x 2
   - SQL注入漏洞 x 1
   
   Major问题（15个）:
   - 方法复杂度过高 x 5
   - 代码重复 x 4
   - 命名不规范 x 3
   - 缺少异常处理 x 3

2. 影响评估
   AI评估:
   ⚠️ 代码质量较差，Major问题数量过多
   
   问题根源分析:
   - 可能原因1: 代码生成模板质量不高
   - 可能原因2: 业务逻辑过于复杂
   - 可能原因3: 步骤6生成方式选择不当

3. 修复策略
   策略A: 自动修复Critical + 部分Major
   → @bug-detective自动修复3个Critical问题
   → 自动修复5个简单Major问题（命名、格式）
   → 其余10个Major记录待办
   → 继续流程
   
   策略B: 返回步骤6重新生成（推荐）
   → 切换生成方式（如之前用代码生成器，改用AI生成）
   → 调整生成参数
   → 重新生成更高质量代码
   
   策略C: 全部手动修复（不推荐）
   → 逐个修复18个问题
   → 耗时预计60-90分钟

4. 用户选择后执行
   [根据选择执行对应回滚操作]
```

### 场景4: "Git提交后发现遗漏关键功能"
```markdown
问题: 步骤11已提交代码，但发现遗漏了一个关键功能

解决流程:
1. 评估遗漏严重性
   AI分析:
   - 遗漏功能是否影响核心业务
   - 是否需要修改数据库结构
   - 是否需要修改已有代码

2. 处理策略
   情况A: 仅需新增功能（不影响已有代码）
   → 无需回滚
   → 作为新的迭代继续开发
   → 新增提交
   
   情况B: 需修改已有功能
   → 是否已推送?
      ├─ 未推送 → 修改代码 → git commit --amend
      └─ 已推送 → 新增提交（不使用--amend）
   
   情况C: 需重大调整（回滚）
   → 评估已推送影响范围
   → 如仅个人分支 → 可考虑回滚
   → 如已合并主分支 → 不可回滚，只能新增提交修复

3. 执行操作
   # 情况A: 新增功能
   # 正常开发流程，新建提交
   
   # 情况B: 修改已有（未推送）
   git add .
   git commit --amend --no-edit
   
   # 情况B: 修改已有（已推送）
   git add .
   git commit -m "fix: 补充遗漏的XX功能"
   git push
   
   # 情况C: 回滚（未推送）
   git reset --soft HEAD~1
   # 修改代码
   git add .
   git commit -m "feat: 完整实现XX功能（修正）"
```

---

## 📝 回滚记录模板

每次执行回滚后，必须在 `docs/项目状态.md` 中记录：

```markdown
## 🔄 回滚记录

### 回滚 #1
- **时间**: 2026-01-29 15:30:00
- **触发步骤**: 步骤6 - 后端开发
- **失败原因**: 代码生成后@code-reviewer发现3个Critical问题，自动修复3次失败
- **回滚级别**: L2 - 中等回滚
- **回滚范围**: 删除Service层代码
- **回滚方案**: 返回步骤6，切换生成方式（代码生成器 → AI生成）
- **影响文件**: 
  - ruoyi-modules/ruoyi-sport/src/main/java/org/dromara/sport/service/
- **执行命令**:
  ```bash
  rm -rf ruoyi-modules/ruoyi-sport/src/main/java/org/dromara/sport/service/
  ```
- **重新执行**: 步骤6（使用AI生成）
- **结果**: ✅ 成功，代码质量提升，无Critical问题
- **教训**: 
  - 复杂业务逻辑建议使用AI生成而非代码生成器
  - 代码生成器更适合标准CRUD
- **预防措施**: 
  - 在步骤5.5增加业务复杂度评估
  - 建议复杂度>5时使用AI生成

### 回滚 #2
[下一次回滚记录]
```

---

## ✅ 回滚检查清单

执行回滚前必须确认：

```markdown
回滚前检查清单

□ 1. 用户明确确认回滚操作
   - 用户已了解回滚范围
   - 用户已了解回滚风险
   - 用户已选择回滚方案

□ 2. 数据备份完成
   - 代码已备份（如需要）
   - 数据库已备份（如涉及）
   - Git提交已记录

□ 3. 影响范围明确
   - 列出将被删除的文件
   - 列出将被回滚的提交
   - 列出将被删除的数据库表

□ 4. 回滚命令准备
   - Git回滚命令已准备
   - 数据库回滚命令已准备
   - 文件删除命令已准备

□ 5. 恢复计划明确
   - 明确从哪个步骤重新开始
   - 明确需要调整的策略
   - 明确预期的修复时间

□ 6. 文档记录准备
   - 回滚原因已记录
   - 回滚方案已记录
   - 教训和预防措施已记录

□ 7. 团队协调（如需要）
   - 通知相关团队成员
   - 确认无其他人依赖当前分支
   - 避免Git冲突

全部确认后，执行回滚操作。
```

---

## 📞 支持与反馈

### 回滚失败怎么办？

如果回滚操作本身失败：

1. **停止所有操作**
2. **保留现场**（不要继续执行命令）
3. **记录错误信息**
4. **寻求帮助**：
   - 查看Git/数据库错误日志
   - 检查文件权限
   - 检查磁盘空间

### 联系支持

遇到无法解决的回滚问题，请提供：
- 失败步骤
- 错误信息
- 已执行的回滚命令
- 项目状态文档

---

**文档版本**: v1.0.0  
**最后更新**: 2026-01-29  
**维护者**: dev工作流团队
