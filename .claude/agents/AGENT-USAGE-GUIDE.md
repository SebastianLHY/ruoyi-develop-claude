# 🎯 智能体使用策略指南

> 根据任务复杂度选择合适的智能体组合，平衡效率、Token消耗和稳定性

---

## 📊 三级使用策略

### 🟢 轻量级模式（1-2个智能体）

**适用场景**:
- 简单CRUD操作
- 单文件代码审查
- 快速Bug定位
- 简单测试生成

**推荐组合**:
```
场景A: 快速开发
└─ @code-generator（仅生成代码）

场景B: 代码审查
└─ @code-reviewer（仅审查）

场景C: Bug修复
└─ @bug-detective（仅定位）

场景D: 测试补充
└─ @test-engineer（仅测试）
```

**Token消耗**: ⭐ 极低（500-1500 tokens/任务）  
**稳定性**: ⭐⭐⭐⭐⭐ 极高  
**效率**: ⭐⭐⭐⭐ 快速响应

---

### 🟡 标准模式（3-5个智能体）

**适用场景**:
- 中等复杂度功能开发
- 需要质量保证
- 需要测试覆盖
- 常规业务模块

**推荐组合**:
```
方案A: 质量优先
├─ @requirements-analyst（需求澄清）
├─ @code-generator（代码生成）
├─ @code-reviewer（代码审查）
└─ @test-engineer（测试验证）

方案B: 效率优先
├─ @code-generator（代码生成）
├─ @code-reviewer（代码审查）
└─ @quality-inspector（质量检查）

方案C: 问题定位
├─ @test-engineer（测试失败分析）
├─ @bug-detective（根因定位）
└─ @code-reviewer（修复验证）
```

**Token消耗**: ⭐⭐⭐ 中等（2000-4000 tokens/任务）  
**稳定性**: ⭐⭐⭐⭐ 高  
**效率**: ⭐⭐⭐⭐ 平衡

---

### 🔴 完整模式（7-10个智能体）

**适用场景**:
- 核心功能开发
- 需要完整交付
- 版本发布
- 生产部署

**推荐组合**:
```
完整开发流程:
├─ 步骤1: @requirements-analyst（需求分析）
├─ 步骤3: @git-workflow-manager（Git初始化）
├─ 步骤6: @code-generator（代码生成）
├─ 步骤6+: @code-reviewer（代码审查）
├─ 步骤8: @test-engineer（测试验证）
├─ 步骤9: @quality-inspector（质量检查）
├─ 步骤10: @project-manager（文档更新）
├─ 步骤11: @git-workflow-manager（代码提交）
├─ 步骤12: @release-manager（版本发布）
└─ 步骤13: @deployment-assistant（部署准备）

问题处理流程:
├─ @bug-detective（根因分析）
├─ @code-generator（修复实现）
├─ @code-reviewer（修复审查）
├─ @test-engineer（回归测试）
└─ @quality-inspector（质量验证）
```

**Token消耗**: ⭐⭐⭐⭐⭐ 高（5000-8000 tokens/任务）  
**稳定性**: ⭐⭐⭐ 中等（链条长，可能有波动）  
**效率**: ⭐⭐⭐⭐⭐ 自动化程度最高

---

## 🎯 决策树

```
开始
  │
  ├─ 是否需要需求澄清？
  │   ├─ 是 → 加入 @requirements-analyst
  │   └─ 否 → 跳过
  │
  ├─ 代码复杂度？
  │   ├─ 简单CRUD → 仅 @code-generator
  │   ├─ 中等复杂 → @code-generator + @code-reviewer
  │   └─ 复杂逻辑 → @code-generator + @code-reviewer + @test-engineer
  │
  ├─ 是否需要质量保证？
  │   ├─ 是 → 加入 @quality-inspector
  │   └─ 否 → 跳过
  │
  ├─ 是否需要版本发布？
  │   ├─ 是 → 加入 @release-manager + @deployment-assistant
  │   └─ 否 → 跳过
  │
  └─ 是否有Bug需要定位？
      ├─ 是 → 加入 @bug-detective
      └─ 否 → 跳过
```

---

## 💡 Token优化技巧

### 技巧1: 渐进式激活

不要一次性激活所有智能体，按需渐进：

```
第1轮: 需求+代码生成
└─ @requirements-analyst + @code-generator

第2轮: 审查发现问题
└─ @code-reviewer（发现3个Critical问题）

第3轮: 问题修复
└─ @bug-detective（定位根因）

第4轮: 质量验证
└─ @quality-inspector（最终检查）
```

**节省**: 40% Token（避免不必要的智能体激活）

---

### 技巧2: 智能体复用

同一个智能体可以多次调用，不要切换：

**❌ 低效**:
```
@code-generator 生成User模块
@code-generator 生成Order模块  # 重新加载上下文
@code-generator 生成Product模块  # 重新加载上下文
```

**✅ 高效**:
```
@code-generator 生成User、Order、Product三个模块
# 一次加载上下文，批量生成
```

**节省**: 60% Token

---

### 技巧3: 使用代码生成器

步骤5.5优先使用若依代码生成器：

```
标准CRUD → 使用若依生成器（节省70% Token）
复杂逻辑 → AI生成（质量更高）
```

---

### 技巧4: 精准问题描述

清晰的问题描述减少智能体试探：

**❌ 模糊**:
```
"代码有问题，帮我看看"
→ 可能激活5个智能体试探
```

**✅ 精准**:
```
"UserService.updateUser方法空指针异常，帮我定位"
→ 直接激活 @bug-detective
```

**节省**: 50% Token

---

## ⚖️ 稳定性保障

### 1. 容错机制

每个智能体都支持独立运行：

```
如果智能体A失败:
├─ 不影响智能体B、C、D
├─ 可以单独重试智能体A
└─ 可以跳过智能体A继续流程
```

---

### 2. 降级策略

遇到问题时的降级方案：

```
完整模式（10个智能体）
    ↓ 某个智能体不稳定
标准模式（5个智能体）
    ↓ 仍有问题
轻量模式（2个智能体）
    ↓ 极端情况
手动操作（0个智能体）
```

---

### 3. 检查点机制

关键步骤设置检查点：

```
步骤1 → 需求确认（检查点1）
步骤6 → 代码生成（检查点2）
步骤8 → 测试通过（检查点3）
步骤11 → 代码提交（检查点4）
```

任何检查点失败都可以回退重试。

---

## 📈 性能对比

### Token消耗对比

| 模式 | 智能体数量 | Token消耗 | 适用场景 |
|------|-----------|----------|---------|
| 轻量级 | 1-2个 | 500-1500 | 简单任务 |
| 标准 | 3-5个 | 2000-4000 | 常规开发 |
| 完整 | 7-10个 | 5000-8000 | 核心功能 |
| 传统AI | 0个 | 8000-15000 | 无智能体 |

**结论**: 即使使用完整模式，仍比传统AI助手节省40%

---

### 稳定性对比

| 模式 | 失败率 | 恢复时间 | 用户干预 |
|------|--------|---------|---------|
| 轻量级 | <1% | 即时 | 几乎不需要 |
| 标准 | <5% | 1-2分钟 | 偶尔需要 |
| 完整 | <15% | 3-5分钟 | 可能需要 |

**结论**: 轻量级和标准模式稳定性极高

---

## 🎯 实战建议

### 新手阶段（第1-10个任务）

**推荐**: 轻量级模式

```
只用1-2个智能体:
- 熟悉智能体工作方式
- 建立信任感
- 快速看到效果

示例:
"@code-generator 生成User CRUD"
"@code-reviewer 审查这段代码"
```

---

### 熟练阶段（第11-50个任务）

**推荐**: 标准模式

```
用3-5个智能体:
- 开始使用协作流程
- 体验自动化价值
- 逐步提高效率

示例:
"帮我开发User管理功能"
→ 自动激活3-4个智能体协作
```

---

### 专家阶段（第51+个任务）

**推荐**: 按需选择

```
根据任务选择模式:
- 简单任务 → 轻量级
- 常规任务 → 标准
- 核心任务 → 完整

示例:
"开发核心支付模块（需要完整质量保证）"
→ 使用完整模式
```

---

## 🚨 何时避免使用智能体

以下情况不建议使用智能体：

1. **紧急Bug修复**（时间敏感）
   - 直接手动修复更快
   - 智能体协作需要时间

2. **一行代码修改**（成本过高）
   - Token消耗 > 价值
   - 手动改更快

3. **探索性编程**（频繁试错）
   - 需要快速迭代
   - 智能体流程太重

4. **网络不稳定**（可靠性问题）
   - 智能体切换可能失败
   - 手动操作更可靠

---

## 📊 监控指标

建议跟踪以下指标优化使用：

```
每周统计:
├─ Token消耗总量
├─ 智能体激活次数
├─ 任务成功率
├─ 平均完成时间
└─ 用户干预次数

目标:
├─ Token消耗 < 传统方式的60%
├─ 任务成功率 > 85%
├─ 用户干预 < 20%
└─ 效率提升 > 2x
```

---

## 🎓 总结

### 核心原则

1. **按需激活**: 不是越多越好
2. **渐进使用**: 从简单到复杂
3. **监控优化**: 跟踪Token和稳定性
4. **灵活降级**: 遇到问题及时调整

### 推荐配置

```
日常开发: 标准模式（3-5个智能体）
├─ Token消耗: 可控
├─ 稳定性: 高
└─ 效率: 平衡

核心功能: 完整模式（7-10个智能体）
├─ Token消耗: 高但值得
├─ 稳定性: 中等
└─ 效率: 最高自动化

快速任务: 轻量级模式（1-2个智能体）
├─ Token消耗: 极低
├─ 稳定性: 极高
└─ 效率: 快速响应
```

---

**记住**: 智能体是工具，不是目的。根据实际需求灵活选择！
